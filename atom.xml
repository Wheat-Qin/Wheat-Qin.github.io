<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>喂：一二三</title>
  
  <subtitle>低调、踏实、前行。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://guohuaden.com/"/>
  <updated>2019-04-06T07:58:53.807Z</updated>
  <id>http://guohuaden.com/</id>
  
  <author>
    <name>Wheat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>每日算法--篇二</title>
    <link href="http://guohuaden.com/2019/04/05/Arithmetic-daily2/"/>
    <id>http://guohuaden.com/2019/04/05/Arithmetic-daily2/</id>
    <published>2019-04-05T03:58:52.000Z</published>
    <updated>2019-04-06T07:58:53.807Z</updated>
    
    <content type="html"><![CDATA[<h3 id="找出数组中重复的数字"><a href="#找出数组中重复的数字" class="headerlink" title="找出数组中重复的数字"></a>找出数组中重复的数字</h3><h4 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h4><p>在一个长度为n的数组里的所有数字都在0~n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如：如果输入长度为 7 的数组{2，3，1，0，2，5，3}，那么对应的输出是重复的数字2或者3。</p><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>从数组中找出重复的数字，如果没有提示！</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>遍历数组进行匹配，考虑时间复杂度问题。</p><h4 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h4><h5 id="1、双重遍历"><a href="#1、双重遍历" class="headerlink" title="1、双重遍历"></a>1、双重遍历</h5><p>将数组中的每一个数与其他数做匹配，如果两者相等，输出，否则输出未找到提示。</p><h5 id="2、排序-遍历"><a href="#2、排序-遍历" class="headerlink" title="2、排序+遍历"></a>2、排序+遍历</h5><p>将数组排序，匹配相邻者数字，如果两者相等，输出，否则输出未找到提示。</p><h4 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践:"></a>代码实践:</h4><p><strong>双重遍历</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> number = arr[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i;j&lt;len;j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (number == arr[j]) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,number);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"未找到"</span>);</span><br></pre></td></tr></table></figure><p><strong>排序+遍历</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="keyword">int</span> i,j,temp;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">temp = arr[i];</span><br><span class="line"><span class="keyword">for</span> (j=i;j&gt;<span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>]&gt;temp;j--)&#123;</span><br><span class="line">arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">BOOL result = NO;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> number = arr[index];</span><br><span class="line"><span class="keyword">int</span> next = arr[index+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (number == next) &#123;</span><br><span class="line">result = YES;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"--%d---"</span>,number);</span><br><span class="line">&#125;</span><br><span class="line">index = index+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result == NO)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"未找到"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;找出数组中重复的数字&quot;&gt;&lt;a href=&quot;#找出数组中重复的数字&quot; class=&quot;headerlink&quot; title=&quot;找出数组中重复的数字&quot;&gt;&lt;/a&gt;找出数组中重复的数字&lt;/h3&gt;&lt;h4 id=&quot;描述：&quot;&gt;&lt;a href=&quot;#描述：&quot; class=&quot;header
      
    
    </summary>
    
      <category term="每日算法" scheme="http://guohuaden.com/categories/%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="每日算法、算法" scheme="http://guohuaden.com/tags/%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>每日算法--篇一</title>
    <link href="http://guohuaden.com/2019/04/04/Arithmetic-daily1/"/>
    <id>http://guohuaden.com/2019/04/04/Arithmetic-daily1/</id>
    <published>2019-04-04T02:27:55.000Z</published>
    <updated>2019-04-06T07:48:15.618Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题：找出有序数组中和等于指定数的两个数"><a href="#题：找出有序数组中和等于指定数的两个数" class="headerlink" title="题：找出有序数组中和等于指定数的两个数"></a>题：找出有序数组中和等于指定数的两个数</h3><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>数组是有序的；数组中可能存在两个数相加的和等于给定的值，找出这两个数，如果没有提示。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>首先想到的必须遍历数组，这点是毋庸置疑的。这时需要考虑的就是怎样遍历数组以及时间复杂度问题。</p><h4 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h4><h5 id="1、双重遍历"><a href="#1、双重遍历" class="headerlink" title="1、双重遍历"></a>1、双重遍历</h5><p>最简单也是最笨重的想法是双重遍历：将每个数与另外的数相加，判断是否等于目标值，时间复杂度为O(n*n)。</p><h5 id="2、快速查找法"><a href="#2、快速查找法" class="headerlink" title="2、快速查找法"></a>2、快速查找法</h5><p><strong>方法一：</strong>从两端开始，分别向中间取值匹配。时间复杂度为O(n)。</p><p>(1)如果两数之和&gt;目标值,说明较大加数需要小些，向数组的较小值方向移位取值继续和原较小值重新匹配。</p><p>(2)如果两数之和&lt;目标值,说明较小加数需要大些，向数组的较大值方向移位取值继续和原较大值重新匹配。</p><p><strong>方法二：</strong>近一步思考：以数组中间下标(index)为分界点，分别向左右两边取值匹配。时间复杂度为O(n)。</p><p>  （1）若两数之和&gt;目标值，说明较小加数还要再小，向数组的较小值方向移位取值与原较大值重新匹配。</p><p>  （2）若两数之和&lt;目标值，说明较大加数还要再大，向数组的较大值方向移位取值与原较小值重新匹配。</p><p><strong>方法三：</strong>换一种方式思考，    两个加数一定满足条件：较小加数小于等于目标值的一半，并且较大值大于等于目标值的一半（较小加数&lt;= (目标值/2) &lt;= 较大加数）；那么只需要找出该数组的较小加数和较大加数分界index，以该分界为起点分别往左右两边逐个取值匹配。比较的方式遵循方法二的(1)(2)。时间复杂度仍为O(n)。</p><h4 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h4><h5 id="双重遍历"><a href="#双重遍历" class="headerlink" title="双重遍历"></a>双重遍历</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">NSInteger targetNumber = 90;</span><br><span class="line">NSArray *arr = @[@&quot;4&quot;,@&quot;8&quot;,@&quot;10&quot;,@&quot;15&quot;,@&quot;20&quot;,@&quot;30&quot;,@&quot;35&quot;,@&quot;49&quot;,@&quot;51&quot;,@&quot;60&quot;,@&quot;60&quot;,@&quot;63&quot;,@&quot;70&quot;,@&quot;89&quot;];</span><br><span class="line">BOOL result = NO;</span><br><span class="line"></span><br><span class="line">for(NSInteger i = 0    ; i&lt; arr.count; i++)&#123;</span><br><span class="line">    NSInteger minNumber = [arr[i] integerValue];</span><br><span class="line">    </span><br><span class="line">    for (NSInteger j = i+1;j&lt; arr.count;j++) &#123;</span><br><span class="line">        NSInteger maxNumber = [arr[j] integerValue];</span><br><span class="line">        if(minNumber + maxNumber == targetNumber )&#123;</span><br><span class="line">            NSLog(@&quot;search3 :::::::%li---%li&quot;,minNumber,maxNumber);</span><br><span class="line">            result = YES;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(result == NO)&#123;</span><br><span class="line">    NSLog(@&quot;未找到&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="快速查找"><a href="#快速查找" class="headerlink" title="快速查找"></a>快速查找</h5><p><strong>方法一：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NSInteger targetNumber = 90;</span><br><span class="line">NSArray *arr = @[@&quot;4&quot;,@&quot;8&quot;,@&quot;10&quot;,@&quot;15&quot;,@&quot;20&quot;,@&quot;24&quot;,@&quot;30&quot;,@&quot;35&quot;,@&quot;49&quot;,@&quot;50&quot;,@&quot;60&quot;,@&quot;63&quot;,@&quot;70&quot;,@&quot;89&quot;];</span><br><span class="line">BOOL result = NO;</span><br><span class="line">NSInteger minIndex = 0 ;</span><br><span class="line">NSInteger maxIndex = arr.count-1;</span><br><span class="line">do &#123;</span><br><span class="line">    NSInteger sumNumber = [arr[minIndex] integerValue]+ [arr[maxIndex] integerValue];</span><br><span class="line">    if(sumNumber &gt; targetNumber)&#123;</span><br><span class="line">        maxIndex -- ;</span><br><span class="line">    &#125;else if(sumNumber &lt; targetNumber)&#123;</span><br><span class="line">        minIndex++;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;%@---%@&quot;,arr[minIndex],arr[maxIndex]);</span><br><span class="line">        minIndex++;</span><br><span class="line">        maxIndex--;</span><br><span class="line">        result = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125; while (minIndex &lt;= maxIndex);</span><br><span class="line"></span><br><span class="line">if(result == NO)&#123;</span><br><span class="line">    NSLog(@&quot;未找到&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">NSInteger targetNumber = 90;</span><br><span class="line">NSArray *arr = @[@&quot;4&quot;,@&quot;8&quot;,@&quot;10&quot;,@&quot;15&quot;,@&quot;20&quot;,@&quot;24&quot;,@&quot;30&quot;,@&quot;35&quot;,@&quot;49&quot;,@&quot;50&quot;,@&quot;60&quot;,@&quot;63&quot;,@&quot;70&quot;,@&quot;89&quot;];</span><br><span class="line">NSInteger midIndex = arr.count*0.5;</span><br><span class="line">BOOL result = NO;</span><br><span class="line">if(midIndex &gt; 0)&#123;</span><br><span class="line">    NSInteger minIndex = midIndex ;</span><br><span class="line">    NSInteger maxIndex = midIndex+1;</span><br><span class="line">    do &#123;</span><br><span class="line">        NSInteger sumNumber = [arr[minIndex] integerValue]+ [arr[maxIndex] integerValue];</span><br><span class="line">        if(sumNumber &gt; targetNumber)&#123;</span><br><span class="line">            minIndex -- ;</span><br><span class="line">        &#125;else if(sumNumber &lt; targetNumber)&#123;</span><br><span class="line">            maxIndex++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            NSLog(@&quot;%@---%@&quot;,arr[minIndex],arr[maxIndex]);</span><br><span class="line">            minIndex--;</span><br><span class="line">            maxIndex++;</span><br><span class="line">            result = YES;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; while (minIndex &gt;= 0 &amp;&amp; maxIndex &lt; arr.count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(result == NO)&#123;</span><br><span class="line">    NSLog(@&quot;未找到&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法三：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">NSInteger targetNumber = 90;</span><br><span class="line">NSArray *arr = @[@&quot;4&quot;,@&quot;8&quot;,@&quot;10&quot;,@&quot;15&quot;,@&quot;20&quot;,@&quot;30&quot;,@&quot;35&quot;,@&quot;49&quot;,@&quot;51&quot;,@&quot;60&quot;,@&quot;60&quot;,@&quot;63&quot;,@&quot;70&quot;,@&quot;89&quot;];</span><br><span class="line">NSInteger midIndex = 0;</span><br><span class="line">BOOL result = NO;</span><br><span class="line">for (NSInteger i = 0;i&lt;arr.count;i++) &#123;</span><br><span class="line">    if([arr[i] integerValue] &gt; targetNumber*0.5)&#123;</span><br><span class="line">        midIndex = i - 1;</span><br><span class="line">        NSLog(@&quot;%ld&quot;,midIndex);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(midIndex != -1)&#123;</span><br><span class="line">    NSInteger minIndex = midIndex;</span><br><span class="line">    NSInteger maxIndex =  midIndex + 1;</span><br><span class="line">    do &#123;   </span><br><span class="line">        NSInteger sumNumber = [arr[minIndex] integerValue]+ [arr[maxIndex] integerValue];</span><br><span class="line">        if (sumNumber &gt; targetNumber) &#123;</span><br><span class="line">            minIndex--;</span><br><span class="line">        &#125;else if(sumNumber &lt; targetNumber)&#123;</span><br><span class="line">            maxIndex++;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            NSLog(@&quot;%@---%@&quot;,arr[minIndex],arr[maxIndex]);</span><br><span class="line">            minIndex--;</span><br><span class="line">            maxIndex++;</span><br><span class="line">            result = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (minIndex &gt;= 0 &amp;&amp; (maxIndex &lt;= arr.count-1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(result == NO)&#123;</span><br><span class="line">    NSLog(@&quot;未找到&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题：找出有序数组中和等于指定数的两个数&quot;&gt;&lt;a href=&quot;#题：找出有序数组中和等于指定数的两个数&quot; class=&quot;headerlink&quot; title=&quot;题：找出有序数组中和等于指定数的两个数&quot;&gt;&lt;/a&gt;题：找出有序数组中和等于指定数的两个数&lt;/h3&gt;&lt;h4 i
      
    
    </summary>
    
      <category term="每日算法" scheme="http://guohuaden.com/categories/%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="每日算法" scheme="http://guohuaden.com/tags/%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>隐私协议</title>
    <link href="http://guohuaden.com/2019/01/25/PrivacyPolicy/"/>
    <id>http://guohuaden.com/2019/01/25/PrivacyPolicy/</id>
    <published>2019-01-25T07:19:56.755Z</published>
    <updated>2019-03-02T11:46:53.652Z</updated>
    
    <content type="html"><![CDATA[<p>本软件尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本软件会按照本隐私权政策的规定使用和披露您的个人信息。但本软件将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本软件不会将这些信息对外披露或向第三方提供。本软件会不时更新本隐私权政策。您在同意本软件服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于本软件服务使用协议不可分割的一部分。</p><h3 id="1-适用范围"><a href="#1-适用范围" class="headerlink" title="1.适用范围"></a>1.适用范围</h3><p>a.在您使用本软件网络服务，本软件自动接收并记录的您的手机上的信息，包括但不限于您的健康数据、使用的语言、访问日期和时间等数据；</p><h3 id="2-信息的使用"><a href="#2-信息的使用" class="headerlink" title="2.信息的使用"></a>2.信息的使用</h3><p>a.在获得您的数据之后，本软件会将其上传至服务器，以便您能够更好地使用服务。</p><h3 id="3-信息披露"><a href="#3-信息披露" class="headerlink" title="3.信息披露"></a>3.信息披露</h3><p>a.本软件不会将您的信息披露给不受信任的第三方。</p><p>b.根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露；</p><p>c.如您出现违反中国有关法律、法规或者相关规则的情况，需要向第三方披露；</p><h3 id="4-信息存储和交换"><a href="#4-信息存储和交换" class="headerlink" title="4.信息存储和交换"></a>4.信息存储和交换</h3><p>本软件收集的有关您的信息和资料将保存在本软件及服务器上，这些信息和资料可能传送至您所在国家、地区或本软件收集信息和资料所在地的境外并在境外被访问、存储和展示。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本软件尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本软件会按照本隐私权政策的规定使用和披露您的个人信息。但本软件将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本软件不会将这些信息对外披露或向第三
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法七：二叉树遍历</title>
    <link href="http://guohuaden.com/2019/01/08/Arithmetic7-BinaryTreeTraverse/"/>
    <id>http://guohuaden.com/2019/01/08/Arithmetic7-BinaryTreeTraverse/</id>
    <published>2019-01-08T12:40:33.000Z</published>
    <updated>2019-01-15T07:44:33.644Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="http://guohuaden.com/categories/algorithm/"/>
    
    
      <category term="算法" scheme="http://guohuaden.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法六：K最近邻算法</title>
    <link href="http://guohuaden.com/2019/01/07/Arithmetic6-KNN/"/>
    <id>http://guohuaden.com/2019/01/07/Arithmetic6-KNN/</id>
    <published>2019-01-07T13:38:58.000Z</published>
    <updated>2019-01-15T07:43:37.612Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="http://guohuaden.com/categories/algorithm/"/>
    
    
      <category term="算法" scheme="http://guohuaden.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法五：迪克特斯拉算法</title>
    <link href="http://guohuaden.com/2019/01/06/Arithmetic5-Dijkstra/"/>
    <id>http://guohuaden.com/2019/01/06/Arithmetic5-Dijkstra/</id>
    <published>2019-01-06T14:38:27.000Z</published>
    <updated>2019-01-15T07:42:36.520Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="http://guohuaden.com/categories/algorithm/"/>
    
    
      <category term="算法" scheme="http://guohuaden.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法四：广度优先搜索和深度优先搜索</title>
    <link href="http://guohuaden.com/2019/01/05/Arithmetic4-BFSAndDFS/"/>
    <id>http://guohuaden.com/2019/01/05/Arithmetic4-BFSAndDFS/</id>
    <published>2019-01-05T13:37:34.000Z</published>
    <updated>2019-01-15T07:41:56.637Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="http://guohuaden.com/categories/algorithm/"/>
    
    
      <category term="算法、基础算法" scheme="http://guohuaden.com/tags/%E7%AE%97%E6%B3%95%E3%80%81%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法三：动态规划</title>
    <link href="http://guohuaden.com/2019/01/03/Arithmetic3-DynamicProgramming/"/>
    <id>http://guohuaden.com/2019/01/03/Arithmetic3-DynamicProgramming/</id>
    <published>2019-01-03T13:32:21.000Z</published>
    <updated>2019-01-15T07:35:58.553Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="http://guohuaden.com/categories/algorithm/"/>
    
    
      <category term="基础算法、算法" scheme="http://guohuaden.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法：选择排序</title>
    <link href="http://guohuaden.com/2018/12/31/Arithmetic-Basice-SelectSort/"/>
    <id>http://guohuaden.com/2018/12/31/Arithmetic-Basice-SelectSort/</id>
    <published>2018-12-31T12:52:49.000Z</published>
    <updated>2019-01-15T07:58:28.548Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="基础算法" scheme="http://guohuaden.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="基础算法" scheme="http://guohuaden.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法：插入排序</title>
    <link href="http://guohuaden.com/2018/12/30/Arithmetic-Basice-InsertSort/"/>
    <id>http://guohuaden.com/2018/12/30/Arithmetic-Basice-InsertSort/</id>
    <published>2018-12-30T13:10:56.000Z</published>
    <updated>2019-01-15T07:56:32.133Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="基础算法" scheme="http://guohuaden.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="基础算法" scheme="http://guohuaden.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法基础二：递归和for循环</title>
    <link href="http://guohuaden.com/2018/12/01/Arithmetic2-RecursionAndFor/"/>
    <id>http://guohuaden.com/2018/12/01/Arithmetic2-RecursionAndFor/</id>
    <published>2018-12-01T13:05:51.000Z</published>
    <updated>2019-01-15T07:36:13.468Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="http://guohuaden.com/categories/algorithm/"/>
    
    
      <category term="基础算法" scheme="http://guohuaden.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法：交换排序</title>
    <link href="http://guohuaden.com/2018/11/29/Arithmetic-Basice-ExchangeSort/"/>
    <id>http://guohuaden.com/2018/11/29/Arithmetic-Basice-ExchangeSort/</id>
    <published>2018-11-29T12:54:23.000Z</published>
    <updated>2019-01-15T07:55:49.911Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="基础算法" scheme="http://guohuaden.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="基础算法" scheme="http://guohuaden.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法一：排序</title>
    <link href="http://guohuaden.com/2018/11/28/Arithmetic-basics/"/>
    <id>http://guohuaden.com/2018/11/28/Arithmetic-basics/</id>
    <published>2018-11-28T12:14:26.000Z</published>
    <updated>2019-01-15T07:17:41.450Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="http://guohuaden.com/categories/algorithm/"/>
    
    
      <category term="基础算法" scheme="http://guohuaden.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 七 （SDWebImageTransition）</title>
    <link href="http://guohuaden.com/2018/10/30/Read-SDWebImage-SDWebImageTransition/"/>
    <id>http://guohuaden.com/2018/10/30/Read-SDWebImage-SDWebImageTransition/</id>
    <published>2018-10-30T13:32:19.000Z</published>
    <updated>2018-11-02T08:04:14.448Z</updated>
    
    <content type="html"><![CDATA[<p>该类用于在视图类别加载图像完成后提供过渡动画。 </p><ol><li><p>在<code>UIVit + WebCache.h</code> 中的 <code>sd_imageTransition</code><br> 用于<code>UIKit(iOS和tvOS)</code>，使用<br> <code>+ [UIView transitionWithView：duration：options：animations：completion]</code> 进行过渡动画。 </p></li><li><p>对于<code>AppKit(macOS)</code><br>使用 <code>+ [NSAnimationContext runAnimationGroup：completionHandler：]</code>进行过渡动画。 我们可以调用<code>+ [NSAnimationContext currentContext]</code>来获取动画块中的上下文。 提供这些转换以用于基本用途。 </p></li></ol><ol start="3"><li>如果需要复杂的动画，可以考虑直接使用<code>Core Animation</code>或使用<code>SDWebImageAvoidAutoSetImage</code>并实现自己的后映像加载完成。<a id="more"></a></li></ol><h3 id="动画选项"><a href="#动画选项" class="headerlink" title="动画选项"></a>动画选项</h3><p>分两种情况，如果是 SD_UIKIT 类型，就直接使用系统的动画选项，否则定义的枚举类型只有一种隐式动画</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if SD_UIKIT</span><br><span class="line">typedef UIViewAnimationOptions SDWebImageAnimationOptions;</span><br><span class="line">#else</span><br><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageAnimationOptions) &#123;</span><br><span class="line">    SDWebImageAnimationOptionAllowsImplicitAnimation = 1 &lt;&lt; 0, // specify `allowsImplicitAnimation` for the `NSAnimationContext`</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="三个block代码块"><a href="#三个block代码块" class="headerlink" title="三个block代码块"></a>三个block代码块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//用于动画开始之前要执行的代码块</span><br><span class="line">typedef void (^SDWebImageTransitionPreparesBlock)(__kindof UIView * _Nonnull view, UIImage * _Nullable image, NSData * _Nullable imageData, SDImageCacheType cacheType, NSURL * _Nullable imageURL);</span><br><span class="line"></span><br><span class="line">//用于控制展示动画的代码块</span><br><span class="line">typedef void (^SDWebImageTransitionAnimationsBlock)(__kindof UIView * _Nonnull view, UIImage * _Nullable image);</span><br><span class="line"></span><br><span class="line">//用于动画结束后要执行的代码块</span><br><span class="line">typedef void (^SDWebImageTransitionCompletionBlock)(BOOL finished);</span><br></pre></td></tr></table></figure><h3 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//默认情况下，我们将图像设置为动画开头的视图。 您可以禁用此功能并提供自定义设置图像处理</span><br><span class="line">@property (nonatomic, assign) BOOL avoidAutoSetImage;</span><br><span class="line"></span><br><span class="line">//过渡动画的持续时间，以秒为单位。 默认为0.5。</span><br><span class="line">@property (nonatomic, assign) NSTimeInterval duration;</span><br><span class="line"></span><br><span class="line">//用于此过渡动画（macOS）中所有动画的计时功能。</span><br><span class="line">@property (nonatomic, strong, nullable) CAMediaTimingFunction *timingFunction NS_AVAILABLE_MAC(10_7);</span><br><span class="line"></span><br><span class="line">//一个动画选项</span><br><span class="line">@property (nonatomic, assign) SDWebImageAnimationOptions animationOptions;</span><br><span class="line"></span><br><span class="line">//动画开始前所要执行的代码块</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageTransitionPreparesBlock prepares;</span><br><span class="line"></span><br><span class="line">动画代码块</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageTransitionAnimationsBlock animations;</span><br><span class="line"></span><br><span class="line">//动画结束时要执行的代码块。</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageTransitionCompletionBlock completion;</span><br></pre></td></tr></table></figure><h3 id="Conveniences分类"><a href="#Conveniences分类" class="headerlink" title="Conveniences分类"></a>Conveniences分类</h3><p>创建过渡的便捷方式 如果需要，请记住指定持续时间。 对于UIKit，这些转换只使用对应的<code>animationOptions</code>。 默认情况下，我们启用<code>UIViewAnimationOptionAllowUserInteraction</code>以允许用户在转换期间进行交互。 对于AppKit，这些过渡在“动画”中使用了Core Animation。 因此，您的视图必须是图层支持的。 在应用之前设置<code>wantsLayer = YES</code>。</p><h4 id="公共属性和方法"><a href="#公共属性和方法" class="headerlink" title="公共属性和方法"></a>公共属性和方法</h4><p>调用不同的类属性获取不同的动画效果，如果类属性不可用，就调用类方法类获取不同的动画效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#if __has_feature(objc_class_property)</span><br><span class="line">/// 淡出过渡。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *fadeTransition;</span><br><span class="line">/// 从左转换翻转。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *flipFromLeftTransition;</span><br><span class="line">/// 从右转换翻转。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *flipFromRightTransition;</span><br><span class="line">/// 从顶部过渡翻转。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *flipFromTopTransition;</span><br><span class="line">/// 从底部过渡翻转。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *flipFromBottomTransition;</span><br><span class="line">/// 卷起过渡。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *curlUpTransition;</span><br><span class="line">/// 向下弯曲过渡。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *curlDownTransition;</span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">+ (nonnull instancetype)fadeTransition;</span><br><span class="line">+ (nonnull instancetype)flipFromLeftTransition;</span><br><span class="line">+ (nonnull instancetype)flipFromRightTransition;</span><br><span class="line">+ (nonnull instancetype)flipFromTopTransition;</span><br><span class="line">+ (nonnull instancetype)flipFromBottomTransition;</span><br><span class="line">+ (nonnull instancetype)curlUpTransition;</span><br><span class="line">+ (nonnull instancetype)curlDownTransition;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h3><p><code>SDWebImageTransition</code> 只有一个初始化方法，设置了动画时间为0.5秒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@implementation SDWebImageTransition</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        self.duration = 0.5;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>SDWebImageTransition 分类中创建了不同的动画,这里区别了SD_UIKIT 和 其他。（即iOS 、tvOS、部分watchOS ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">+ (SDWebImageTransition *)fadeTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionCrossDissolve | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionFade;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)flipFromLeftTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionFlipFromLeft | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionPush;</span><br><span class="line">        trans.subtype = kCATransitionFromLeft;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)flipFromRightTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionFlipFromRight | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionPush;</span><br><span class="line">        trans.subtype = kCATransitionFromRight;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)flipFromTopTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionFlipFromTop | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionPush;</span><br><span class="line">        trans.subtype = kCATransitionFromTop;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)flipFromBottomTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionFlipFromBottom | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionPush;</span><br><span class="line">        trans.subtype = kCATransitionFromBottom;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)curlUpTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionCurlUp | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionReveal;</span><br><span class="line">        trans.subtype = kCATransitionFromTop;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)curlDownTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionCurlDown | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionReveal;</span><br><span class="line">        trans.subtype = kCATransitionFromBottom;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该类用于在视图类别加载图像完成后提供过渡动画。 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;UIVit + WebCache.h&lt;/code&gt; 中的 &lt;code&gt;sd_imageTransition&lt;/code&gt;&lt;br&gt; 用于&lt;code&gt;UIKit(iOS和tvOS)&lt;/code&gt;，使用&lt;br&gt; &lt;code&gt;+ [UIView transitionWithView：duration：options：animations：completion]&lt;/code&gt; 进行过渡动画。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于&lt;code&gt;AppKit(macOS)&lt;/code&gt;&lt;br&gt;使用 &lt;code&gt;+ [NSAnimationContext runAnimationGroup：completionHandler：]&lt;/code&gt;进行过渡动画。 我们可以调用&lt;code&gt;+ [NSAnimationContext currentContext]&lt;/code&gt;来获取动画块中的上下文。 提供这些转换以用于基本用途。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;如果需要复杂的动画，可以考虑直接使用&lt;code&gt;Core Animation&lt;/code&gt;或使用&lt;code&gt;SDWebImageAvoidAutoSetImage&lt;/code&gt;并实现自己的后映像加载完成。
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 六 （SDWebImagePrefetcher）</title>
    <link href="http://guohuaden.com/2018/10/27/Read-SDWebImage-SDWebImagePrefetcher/"/>
    <id>http://guohuaden.com/2018/10/27/Read-SDWebImage-SDWebImagePrefetcher/</id>
    <published>2018-10-27T14:32:36.000Z</published>
    <updated>2018-11-02T08:04:38.551Z</updated>
    
    <content type="html"><![CDATA[<p><code>SDWebImagePrefetcher</code> 预先下载（预加载）图片，以方便后续使用，主要是用于部分图片需要先行下载并存储的情况。预先取出缓存中的一些URLs以供将来使用。 图像以低优先级下载。</p><p><code>SDWebImagePrefetcher</code> 设计了两种回调方式：</p><ol><li><p><code>SDWebImagePrefetcherDelegate</code><br>用来处理每一个预下载完成的回调，以及所有下载完成的回调 </p></li><li><p><code>block</code><br>用来处理整体进度的回调，返回的是下载完成的数量和总数量等</p></li></ol><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@protocol SDWebImagePrefetcherDelegate &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 在预加载图片时调用。</span><br><span class="line"> *</span><br><span class="line"> * @param imagePrefetcher 当前图片预加载类</span><br><span class="line"> * @param imageURL       预加载的图片网址</span><br><span class="line"> * @param finishedCount   预加载的图片总数（成功与否）</span><br><span class="line"> * @param totalCount      预加载的图片总数</span><br><span class="line"> */</span><br><span class="line">- (void)imagePrefetcher:(nonnull SDWebImagePrefetcher *)imagePrefetcher didPrefetchURL:(nullable NSURL *)imageURL finishedCount:(NSUInteger)finishedCount totalCount:(NSUInteger)totalCount;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 在预加载所有图像时调用。</span><br><span class="line"> * @param imagePrefetcher 当前图片的预加载类</span><br><span class="line"> * @param totalCount      预加载的图片总数（无论是否成功）</span><br><span class="line"> * @param skippedCount    跳过的图片总数</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">- (void)imagePrefetcher:(nonnull SDWebImagePrefetcher *)imagePrefetcher didFinishWithTotalCount:(NSUInteger)totalCount skippedCount:(NSUInteger)skippedCount;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="两个block代码块"><a href="#两个block代码块" class="headerlink" title="两个block代码块"></a>两个block代码块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 预加载进度block</span><br><span class="line"> @param noOfFinishedUrls 已经完成的数量，无论成功失败</span><br><span class="line"> @param noOfTotalUrls    总数量</span><br><span class="line"> */</span><br><span class="line">typedef void(^SDWebImagePrefetcherProgressBlock)(NSUInteger noOfFinishedUrls, NSUInteger noOfTotalUrls);</span><br><span class="line">/**</span><br><span class="line"> 预加载完成block</span><br><span class="line"></span><br><span class="line"> @param noOfFinishedUrls 已经完成的数量，无论成功失败</span><br><span class="line"> @param noOfSkippedUrls  跳过的数量</span><br><span class="line"> */</span><br><span class="line">typedef void(^SDWebImagePrefetcherCompletionBlock)(NSUInteger noOfFinishedUrls, NSUInteger noOfSkippedUrls);</span><br></pre></td></tr></table></figure><h3 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 网络图片管理器,只读</span><br><span class="line"> */</span><br><span class="line">@property (strong, nonatomic, readonly, nonnull) SDWebImageManager *manager;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *同时预加载的最大URL数。 默认为3。</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign) NSUInteger maxConcurrentDownloads;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 预加载的SDWebImageOptions选项。 默认为SDWebImageLowPriority。</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign) SDWebImageOptions options;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Prefetcher的队列选项。 默认为主队列。</span><br><span class="line"> */</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_queue_t prefetcherQueue;</span><br><span class="line"></span><br><span class="line">//协议</span><br><span class="line">@property (weak, nonatomic, nullable) id &lt;SDWebImagePrefetcherDelegate&gt; delegate;</span><br></pre></td></tr></table></figure><h3 id="方法声明"><a href="#方法声明" class="headerlink" title="方法声明"></a>方法声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回全局图像预加载实例。</span><br><span class="line"> */</span><br><span class="line">+ (nonnull instancetype)sharedImagePrefetcher;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 允许您使用任意图像管理器实例化预加载类。</span><br><span class="line"> */</span><br><span class="line">- (nonnull instancetype)initWithImageManager:(nonnull SDWebImageManager *)manager NS_DESIGNATED_INITIALIZER;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 分配URL列表以让SDWebImagePrefetcher对预加载进行排队</span><br><span class="line"> * 目前一次下载一张图片，并跳过下载失败的图像，然后进入列表中的下一个图像。任何先前运行的预加载操作都将被取消。</span><br><span class="line"> * @param urls 预加载的URL列表</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">- (void)prefetchURLs:(nullable NSArray&lt;NSURL *&gt; *)urls;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 分配URL列表以让SDWebImagePrefetcher对预加载进行排队，目前一次下载一张图片，并跳过下载失败的图像，然后进入列表中的下一个图像。任何先前运行的预加载操作都将被取消。</span><br><span class="line"> * currently one image is downloaded at a time,</span><br><span class="line"> * and skips images for failed downloads and proceed to the next image in the list.</span><br><span class="line"> * Any previously-running prefetch operations are canceled.</span><br><span class="line"> *</span><br><span class="line"> * @param urls           预加载的URL列表</span><br><span class="line"> * @param progressBlock   block块在进度更新时被调用;</span><br><span class="line"> *                        第一个参数是已完成（成功或未成功）请求的数量，</span><br><span class="line"> *                        第二个参数是最初请求预加载的图像总数</span><br><span class="line"> * @param completionBlock Block块在预加载完成时被调用</span><br><span class="line"> *                       第一个参数是已完成（成功或未成功）请求的数量，</span><br><span class="line"> *                        第二个参数是跳过的请求数</span><br><span class="line"> */</span><br><span class="line">- (void)prefetchURLs:(nullable NSArray&lt;NSURL *&gt; *)urls</span><br><span class="line">            progress:(nullable SDWebImagePrefetcherProgressBlock)progressBlock</span><br><span class="line">           completed:(nullable SDWebImagePrefetcherCompletionBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 删除并取消排队列表</span><br><span class="line"> */</span><br><span class="line">- (void)cancelPrefetching;</span><br></pre></td></tr></table></figure><h3 id="私有属性声明"><a href="#私有属性声明" class="headerlink" title="私有属性声明"></a>私有属性声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//.h文件manager管理器声明为只读，这里声明为读写类型。实现外部只能访问，内部可读写。</span><br><span class="line">@property (strong, nonatomic, nonnull) SDWebImageManager *manager;</span><br><span class="line">//可以从不同的队列访问</span><br><span class="line">@property (strong, atomic, nullable) NSArray&lt;NSURL *&gt; *prefetchURLs; </span><br><span class="line"></span><br><span class="line">//已请求的数量</span><br><span class="line">@property (assign, nonatomic) NSUInteger requestedCount;</span><br><span class="line">//已跳过的数量</span><br><span class="line">@property (assign, nonatomic) NSUInteger skippedCount;</span><br><span class="line">//已完成的数量</span><br><span class="line">@property (assign, nonatomic) NSUInteger finishedCount;</span><br><span class="line">//已开始的时间</span><br><span class="line">@property (assign, nonatomic) NSTimeInterval startedTime;</span><br><span class="line">//预加载图片完成代码块</span><br><span class="line">@property (copy, nonatomic, nullable) SDWebImagePrefetcherCompletionBlock completionBlock;</span><br><span class="line">//预加载图片进度代码块</span><br><span class="line">@property (copy, nonatomic, nullable) SDWebImagePrefetcherProgressBlock progressBlock;</span><br></pre></td></tr></table></figure><h3 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h3><p>初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ (nonnull instancetype)sharedImagePrefetcher &#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    static id instance;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">        instance = [self new];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)init &#123;</span><br><span class="line">    return [self initWithImageManager:[SDWebImageManager new]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)initWithImageManager:(SDWebImageManager *)manager &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        //图片管理器</span><br><span class="line">        _manager = manager;</span><br><span class="line">        </span><br><span class="line">        预加载的SDWebImageOptions选项。 默认为SDWebImageLowPriority。</span><br><span class="line">        _options = SDWebImageLowPriority;</span><br><span class="line">        //Prefetcher的队列选项。 默认为主队列。</span><br><span class="line">        _prefetcherQueue = dispatch_get_main_queue();</span><br><span class="line">        //同时预加载的最大URL数。 默认为3。</span><br><span class="line">        self.maxConcurrentDownloads = 3;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性get和set方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//同时预加载的最大数的set方法</span><br><span class="line">- (void)setMaxConcurrentDownloads:(NSUInteger)maxConcurrentDownloads &#123;</span><br><span class="line">    self.manager.imageDownloader.maxConcurrentDownloads = maxConcurrentDownloads;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//同时预加载的最大数的get方法</span><br><span class="line">- (NSUInteger)maxConcurrentDownloads &#123;</span><br><span class="line">    return self.manager.imageDownloader.maxConcurrentDownloads;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预加载图片实现方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">- (void)startPrefetchingAtIndex:(NSUInteger)index &#123;</span><br><span class="line">    //创建临时变量，用于存储当前的URL</span><br><span class="line">    NSURL *currentURL;</span><br><span class="line">    </span><br><span class="line">    //同步锁，判断index是否越界，如果越界就返回，否则获取当前的URL，赋值给临时变量currentURL，已请求的数量+1</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        if (index &gt;= self.prefetchURLs.count) return;</span><br><span class="line">        currentURL = self.prefetchURLs[index];</span><br><span class="line">        self.requestedCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //图片管理器加载当前URL的图片</span><br><span class="line">    [self.manager loadImageWithURL:currentURL options:self.options progress:nil completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;</span><br><span class="line">        </span><br><span class="line">        //如果已经完成，返回</span><br><span class="line">        if (!finished) return;</span><br><span class="line">        </span><br><span class="line">        //完成的记数+1</span><br><span class="line">        self.finishedCount++;</span><br><span class="line"></span><br><span class="line">        //如果需要过程回调，执行过程回调操作</span><br><span class="line">        if (self.progressBlock) &#123;</span><br><span class="line">            self.progressBlock(self.finishedCount,(self.prefetchURLs).count);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果图片不存在，跳过的记数+1</span><br><span class="line">        if (!image) &#123;</span><br><span class="line">            // Add last failed</span><br><span class="line">            self.skippedCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果delegate存在，执行delegate方法</span><br><span class="line">        if ([self.delegate respondsToSelector:@selector(imagePrefetcher:didPrefetchURL:finishedCount:totalCount:)]) &#123;</span><br><span class="line">            [self.delegate imagePrefetcher:self</span><br><span class="line">                            didPrefetchURL:currentURL</span><br><span class="line">                             finishedCount:self.finishedCount</span><br><span class="line">                                totalCount:self.prefetchURLs.count</span><br><span class="line">             ];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果预下载的URLs数量大于已经下载的数量，就说明还有没下载完的任务，继续下载下一个。（这里是使用的递归方法）</span><br><span class="line">        if (self.prefetchURLs.count &gt; self.requestedCount) &#123;</span><br><span class="line">            dispatch_async(self.prefetcherQueue, ^&#123;</span><br><span class="line">                // 我们需要调度来避免函数递归调用。 即使对于巨大的URL列表，这也可以防止堆栈溢出</span><br><span class="line">                [self startPrefetchingAtIndex:self.requestedCount];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; else if (self.finishedCount == self.requestedCount) &#123; //如果预下载的URLs数量等于已经下载的数量，说明已经下载完。</span><br><span class="line">        </span><br><span class="line">            //执行预加载完成的delegate方法。</span><br><span class="line">            [self reportStatus];</span><br><span class="line">            </span><br><span class="line">            //如果有需要，执行完成block回调</span><br><span class="line">            if (self.completionBlock) &#123;</span><br><span class="line">                self.completionBlock(self.finishedCount, self.skippedCount);</span><br><span class="line">                </span><br><span class="line">                //将self.completionBlock 置空</span><br><span class="line">                self.completionBlock = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            //将self.progressBlock 置空</span><br><span class="line">            self.progressBlock = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//预加载完成状态的delegate方法</span><br><span class="line">- (void)reportStatus &#123;</span><br><span class="line">    NSUInteger total = (self.prefetchURLs).count;</span><br><span class="line">    if ([self.delegate respondsToSelector:@selector(imagePrefetcher:didFinishWithTotalCount:skippedCount:)]) &#123;</span><br><span class="line">        [self.delegate imagePrefetcher:self</span><br><span class="line">               didFinishWithTotalCount:(total - self.skippedCount)</span><br><span class="line">                          skippedCount:self.skippedCount</span><br><span class="line">         ];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配URL列表使得SDWebImagePrefetcher来安排预加载队列，当前同一时间下载一张图片，忽略下载时间的图片并继续执行列表中的下一张图片。任何之前执行的预加载操作都会被取消。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//urls：预加载的URL列表。</span><br><span class="line">- (void)prefetchURLs:(nullable NSArray&lt;NSURL *&gt; *)urls &#123;</span><br><span class="line">    [self prefetchURLs:urls progress:nil completed:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)prefetchURLs:(nullable NSArray&lt;NSURL *&gt; *)urls</span><br><span class="line">            progress:(nullable SDWebImagePrefetcherProgressBlock)progressBlock</span><br><span class="line">           completed:(nullable SDWebImagePrefetcherCompletionBlock)completionBlock &#123;</span><br><span class="line">    //防止重复的预加载请求</span><br><span class="line">    [self cancelPrefetching]; </span><br><span class="line">    </span><br><span class="line">    //CFAbsoluteTimeGetCurrent() 返回网络时间同步的时钟时间</span><br><span class="line">    self.startedTime = CFAbsoluteTimeGetCurrent();</span><br><span class="line">    </span><br><span class="line">    //预加载的URL列表</span><br><span class="line">    self.prefetchURLs = urls;</span><br><span class="line">    </span><br><span class="line">    代码块</span><br><span class="line">    self.completionBlock = completionBlock;</span><br><span class="line">    self.progressBlock = progressBlock;</span><br><span class="line">    </span><br><span class="line">    //如果预加载的URL列表为空，直接回调完成代码块，没有完成的urls和没有跳过的urls都传0</span><br><span class="line">    if (urls.count == 0) &#123;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock(0,0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 从具有最大允许并发性的列表中的第一个图像开始预加载，然后执行预加载操作</span><br><span class="line">        NSUInteger listCount = self.prefetchURLs.count;</span><br><span class="line">        for (NSUInteger i = 0; i &lt; self.maxConcurrentDownloads &amp;&amp; self.requestedCount &lt; listCount; i++) &#123;</span><br><span class="line">            [self startPrefetchingAtIndex:i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>防止重复的预加载请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)cancelPrefetching &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        self.prefetchURLs = nil;</span><br><span class="line">        self.skippedCount = 0;</span><br><span class="line">        self.requestedCount = 0;</span><br><span class="line">        self.finishedCount = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    [self.manager cancelAll];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;SDWebImagePrefetcher&lt;/code&gt; 预先下载（预加载）图片，以方便后续使用，主要是用于部分图片需要先行下载并存储的情况。预先取出缓存中的一些URLs以供将来使用。 图像以低优先级下载。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SDWebImagePrefetcher&lt;/code&gt; 设计了两种回调方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;SDWebImagePrefetcherDelegate&lt;/code&gt;&lt;br&gt;用来处理每一个预下载完成的回调，以及所有下载完成的回调 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;block&lt;/code&gt;&lt;br&gt;用来处理整体进度的回调，返回的是下载完成的数量和总数量等&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 六（编码器五：SDWebImageGIFCoder）</title>
    <link href="http://guohuaden.com/2018/10/24/Read-SDWebImage-SDWebImageGIFCoder/"/>
    <id>http://guohuaden.com/2018/10/24/Read-SDWebImage-SDWebImageGIFCoder/</id>
    <published>2018-10-24T14:31:13.000Z</published>
    <updated>2018-10-30T07:54:59.419Z</updated>
    
    <content type="html"><![CDATA[<p><code>SDWebImage</code> 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（<code>SDWebImageCodersManager</code>）、编解码协议（<code>SDWebImageCoder</code> 和 <code>SDWebImageProgressiveCoder</code> ）、PNG/JPEG/TIFF编解码，解压缩，显示大图（<code>SDWebImageImageIOCoder</code>）、GIF编解码（<code>SDWebImageGIFCoder</code>）、WebP编解码（<code>SDWebImageWebPCoder</code>）以及辅助类（<code>SDWebImageCoderHelper</code>）。</p><p><code>SDWebImageImageIOCoder</code> ：内置编码器,该类遵守了 <code>SDWebImageCoder</code>协议，但并没有遵守 <code>SDWebImageProgressiveCoder</code>协议，说明该类仅针对git图片的编解码，并不支持git图片的逐行解码功能。<a id="more"></a></p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>判断图片格式是否支持编码，该类仅针对动图的操作，所以仅判断图片的格式是否为GIF格式，如果是返回YES，否则返回NO</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canEncodeToFormat:(SDImageFormat)format &#123;</span><br><span class="line">    return (format == SDImageFormatGIF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据给定的图片格式将图片进行编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">- (NSData *)encodedDataWithImage:(UIImage *)image format:(SDImageFormat)format &#123;</span><br><span class="line">    //如果image不存在，返回nil</span><br><span class="line">    if (!image) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //该类只支持动图的编解码，如果image的格式不是GIF，返回nil</span><br><span class="line">    if (format != SDImageFormatGIF) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //临时变量imageData，用来保存图片数据</span><br><span class="line">    NSMutableData *imageData = [NSMutableData data];</span><br><span class="line">    // 获取GIF图像格式的CFStringRef格式字符串</span><br><span class="line">    CFStringRef imageUTType = [NSData sd_UTTypeFromSDImageFormat:SDImageFormatGIF];</span><br><span class="line">    // 生成图片对象的SDWebImageFrame类型元素的数组</span><br><span class="line">    NSArray&lt;SDWebImageFrame *&gt; *frames = [SDWebImageCoderHelper framesFromAnimatedImage:image];</span><br><span class="line">    </span><br><span class="line">    // 创建图像目标。 GIF不支持EXIF图像方向</span><br><span class="line">    CGImageDestinationRef imageDestination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData, imageUTType, frames.count, NULL);</span><br><span class="line">    </span><br><span class="line">    //如果创建失败，返回nil</span><br><span class="line">    if (!imageDestination) &#123;</span><br><span class="line">        // Handle failure.</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if (frames.count == 0) &#123;</span><br><span class="line">        // 用于静态单个GIF图片（如果是单帧的动图就直接将图片添加到imageDestination中）</span><br><span class="line">        CGImageDestinationAddImage(imageDestination, image.CGImage, nil);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 用于动画的GIF图片</span><br><span class="line">        //// 获取到动图的循环次数</span><br><span class="line">        NSUInteger loopCount = image.sd_imageLoopCount;</span><br><span class="line">        </span><br><span class="line">        // 创建一个动图属性字典保存循环次数</span><br><span class="line">        NSDictionary *gifProperties = @&#123;(__bridge NSString *)kCGImagePropertyGIFDictionary: @&#123;(__bridge NSString *)kCGImagePropertyGIFLoopCount : @(loopCount)&#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        // 为图像目标设置属性</span><br><span class="line">        CGImageDestinationSetProperties(imageDestination, (__bridge CFDictionaryRef)gifProperties);</span><br><span class="line">        </span><br><span class="line">        //循环每一帧的图拼啊</span><br><span class="line">        for (size_t i = 0; i &lt; frames.count; i++) &#123;</span><br><span class="line">             // 获取SDWebImageFrame对象</span><br><span class="line">            SDWebImageFrame *frame = frames[i];</span><br><span class="line">            </span><br><span class="line">            //获取没一帧的显示时间</span><br><span class="line">            float frameDuration = frame.duration;</span><br><span class="line">            </span><br><span class="line">            //获取每一帧取位图图片</span><br><span class="line">            CGImageRef frameImageRef = frame.image.CGImage;</span><br><span class="line">            </span><br><span class="line">            // 创建一个临时变量字典保存每一帧的展示时间</span><br><span class="line">            NSDictionary *frameProperties = @&#123;(__bridge NSString *)kCGImagePropertyGIFDictionary : @&#123;(__bridge NSString *)kCGImagePropertyGIFDelayTime : @(frameDuration)&#125;&#125;;</span><br><span class="line">            </span><br><span class="line">            // 将位图和其对应的属性添加到imageDestination中</span><br><span class="line">            CGImageDestinationAddImage(imageDestination, frameImageRef, (__bridge CFDictionaryRef)frameProperties);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果编码失败就返回nil</span><br><span class="line">    if (CGImageDestinationFinalize(imageDestination) == NO) &#123;</span><br><span class="line">       </span><br><span class="line">        imageData = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 释放imageDestination对象</span><br><span class="line">    CFRelease(imageDestination);</span><br><span class="line">    </span><br><span class="line">    返回图片数据</span><br><span class="line">    return [imageData copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p>判断是否支持图片数据的解码<br>该类仅针对动图的操作，所以仅判断图片的格式是否为GIF格式，如果是支持该图片数据解码，否则返回NO</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canDecodeFromData:(nullable NSData *)data &#123;</span><br><span class="line">    return ([NSData sd_imageFormatForImageData:data] == SDImageFormatGIF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将图片数据解码为图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)decodedImageWithData:(NSData *)data &#123;</span><br><span class="line">    //如果数据为空，返回nil</span><br><span class="line">    if (!data) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">#if SD_MAC</span><br><span class="line">    SDAnimatedImageRep *imageRep = [[SDAnimatedImageRep alloc] initWithData:data];</span><br><span class="line">    NSImage *animatedImage = [[NSImage alloc] initWithSize:imageRep.size];</span><br><span class="line">    [animatedImage addRepresentation:imageRep];</span><br><span class="line">    return animatedImage;</span><br><span class="line">#else</span><br><span class="line">     // 生成图片源</span><br><span class="line">    CGImageSourceRef source = CGImageSourceCreateWithData((__bridge CFDataRef)data, NULL);</span><br><span class="line">    //如果图片源不存在，返回nil</span><br><span class="line">    if (!source) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 获取子图片数量</span><br><span class="line">    size_t count = CGImageSourceGetCount(source);</span><br><span class="line">    </span><br><span class="line">    // 创建临时变量，用来保存动图对象</span><br><span class="line">    UIImage *animatedImage;</span><br><span class="line">    </span><br><span class="line">    //如果子图片个数不大于2，直接将数据转化成图片</span><br><span class="line">    if (count &lt;= 1) &#123;</span><br><span class="line">        animatedImage = [[UIImage alloc] initWithData:data];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 创建可变数组保存SDWebImageFrame对象</span><br><span class="line">        NSMutableArray&lt;SDWebImageFrame *&gt; *frames = [NSMutableArray array];</span><br><span class="line">        </span><br><span class="line">        // 遍历子图片对象，并将其包装成SDWebImageFrame对象</span><br><span class="line">        for (size_t i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            // 获取指定帧数的相位图</span><br><span class="line">            CGImageRef imageRef = CGImageSourceCreateImageAtIndex(source, i, NULL);</span><br><span class="line">            // 如果没获取到就跳过进入下次循环</span><br><span class="line">            if (!imageRef) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 获取指定帧数的持续时间</span><br><span class="line">            float duration = [self sd_frameDurationAtIndex:i source:source];</span><br><span class="line">            </span><br><span class="line">            // 根据相位图生成图片对象</span><br><span class="line">            UIImage *image = [[UIImage alloc] initWithCGImage:imageRef];</span><br><span class="line">            </span><br><span class="line">            // 释放相位图</span><br><span class="line">            CGImageRelease(imageRef);</span><br><span class="line">            </span><br><span class="line">            // 将一帧的信息封装成SDWebImageFrame对象</span><br><span class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:image duration:duration];</span><br><span class="line">            </span><br><span class="line">            // 将封装好的SDWebImageFrame对象添加到数组中保存</span><br><span class="line">            [frames addObject:frame];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 创建临时变量，用来保存循环次数</span><br><span class="line">        NSUInteger loopCount = 1;</span><br><span class="line">        </span><br><span class="line">        // 获取到图片属性</span><br><span class="line">        NSDictionary *imageProperties = (__bridge_transfer NSDictionary *)CGImageSourceCopyProperties(source, nil);</span><br><span class="line">        </span><br><span class="line">        // 获取到GIF相关的图像属性</span><br><span class="line">        NSDictionary *gifProperties = [imageProperties valueForKey:(__bridge NSString *)kCGImagePropertyGIFDictionary];</span><br><span class="line">        </span><br><span class="line">        如果gifProperties存在</span><br><span class="line">        if (gifProperties) &#123;</span><br><span class="line">            //获取GIF循环次数</span><br><span class="line">            NSNumber *gifLoopCount = [gifProperties valueForKey:(__bridge NSString *)kCGImagePropertyGIFLoopCount];</span><br><span class="line">            </span><br><span class="line">            //如果可以转换成NSNumber类型，就将获取到的GIF循环次数赋值给loopCount</span><br><span class="line">            if (gifLoopCount != nil) &#123;</span><br><span class="line">                loopCount = gifLoopCount.unsignedIntegerValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 利用封装好的SDWebImageFrame对象数组生成动图对象</span><br><span class="line">        animatedImage = [SDWebImageCoderHelper animatedImageWithFrames:frames];</span><br><span class="line">        // 设置动图对象的循环次数</span><br><span class="line">        animatedImage.sd_imageLoopCount = loopCount;</span><br><span class="line">        //设置动图的图片格式</span><br><span class="line">        animatedImage.sd_imageFormat = SDImageFormatGIF;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //释放图片源source</span><br><span class="line">    CFRelease(source);</span><br><span class="line">    </span><br><span class="line">    //返回动图</span><br><span class="line">    return animatedImage;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果执行动图的解压操作，就直接返回该图片，动图不支持解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)decompressedImageWithImage:(UIImage *)image</span><br><span class="line">                                   data:(NSData *__autoreleasing  _Nullable *)data</span><br><span class="line">                                options:(nullable NSDictionary&lt;NSString*, NSObject*&gt;*)optionsDict &#123;</span><br><span class="line">    // GIF do not decompress</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><p>获取动图每一帧的显示时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (float)sd_frameDurationAtIndex:(NSUInteger)index source:(CGImageSourceRef)source &#123;</span><br><span class="line">    //临时变量每一帧的显示时间，默认为0.1f</span><br><span class="line">    float frameDuration = 0.1f;</span><br><span class="line">    </span><br><span class="line">    // 获取图片源中指定位置的图片属性</span><br><span class="line">    CFDictionaryRef cfFrameProperties = CGImageSourceCopyPropertiesAtIndex(source, index, nil);</span><br><span class="line">    //如果获取失败，就返回默认每一帧的显示时间</span><br><span class="line">    if (!cfFrameProperties) &#123;</span><br><span class="line">        return frameDuration;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    获取图片属性字典</span><br><span class="line">    NSDictionary *frameProperties = (__bridge NSDictionary *)cfFrameProperties;</span><br><span class="line">    //从图片属性中获取gif属性字典</span><br><span class="line">    NSDictionary *gifProperties = frameProperties[(NSString *)kCGImagePropertyGIFDictionary];</span><br><span class="line">    </span><br><span class="line">    //从git属性中获取当前帧的显示时间</span><br><span class="line">    NSNumber *delayTimeUnclampedProp = gifProperties[(NSString *)kCGImagePropertyGIFUnclampedDelayTime];</span><br><span class="line">    </span><br><span class="line">    //如果当前帧的显示时间不为nil，赋值给frameDuration</span><br><span class="line">    if (delayTimeUnclampedProp != nil) &#123;</span><br><span class="line">        frameDuration = [delayTimeUnclampedProp floatValue];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //如果通过key：kCGImagePropertyGIFUnclampedDelayTime 从gifProperties字典中获取不到当前帧的显示时间，则通过另一个key：kCGImagePropertyGIFDelayTime获取</span><br><span class="line">        NSNumber *delayTimeProp = gifProperties[(NSString *)kCGImagePropertyGIFDelayTime];</span><br><span class="line">        </span><br><span class="line">        //如果不为空，赋值给赋值给frameDuration</span><br><span class="line">        if (delayTimeProp != nil) &#123;</span><br><span class="line">            frameDuration = [delayTimeProp floatValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //许多烦人的广告指定0持续时间，以使图像尽快闪现。 我们遵循Firefox的行为，并为指定持续时间&lt;= 10 ms的任何帧使用100 ms的持续时间。</span><br><span class="line">    </span><br><span class="line">    如果当前帧显示的时间实现小于11ms，就重新设置为100ms</span><br><span class="line">    if (frameDuration &lt; 0.011f) &#123;</span><br><span class="line">        frameDuration = 0.100f;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //释放cfFrameProperties</span><br><span class="line">    CFRelease(cfFrameProperties);</span><br><span class="line">    </span><br><span class="line">    //返回当前帧显示时间</span><br><span class="line">    return frameDuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;SDWebImage&lt;/code&gt; 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（&lt;code&gt;SDWebImageCodersManager&lt;/code&gt;）、编解码协议（&lt;code&gt;SDWebImageCoder&lt;/code&gt; 和 &lt;code&gt;SDWebImageProgressiveCoder&lt;/code&gt; ）、PNG/JPEG/TIFF编解码，解压缩，显示大图（&lt;code&gt;SDWebImageImageIOCoder&lt;/code&gt;）、GIF编解码（&lt;code&gt;SDWebImageGIFCoder&lt;/code&gt;）、WebP编解码（&lt;code&gt;SDWebImageWebPCoder&lt;/code&gt;）以及辅助类（&lt;code&gt;SDWebImageCoderHelper&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SDWebImageImageIOCoder&lt;/code&gt; ：内置编码器,该类遵守了 &lt;code&gt;SDWebImageCoder&lt;/code&gt;协议，但并没有遵守 &lt;code&gt;SDWebImageProgressiveCoder&lt;/code&gt;协议，说明该类仅针对git图片的编解码，并不支持git图片的逐行解码功能。
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 六 （编码器四：SDWebImageImageIOCoder）</title>
    <link href="http://guohuaden.com/2018/10/23/Read-SDWebImage-SDWebImageImageIOCoder/"/>
    <id>http://guohuaden.com/2018/10/23/Read-SDWebImage-SDWebImageImageIOCoder/</id>
    <published>2018-10-23T13:57:30.000Z</published>
    <updated>2018-10-30T02:50:13.633Z</updated>
    
    <content type="html"><![CDATA[<p><code>SDWebImage</code> 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（<code>SDWebImageCodersManager</code>）、编解码协议（<code>SDWebImageCoder</code>）、PNG/JPEG/TIFF编解码，解压缩，显示大图（<code>SDWebImageImageIOCoder</code>）、GIF编解码（<code>SDWebImageGIFCoder</code>）、WebP编解码（<code>SDWebImageWebPCoder</code>）以及辅助类（<code>SDWebImageCoderHelper</code>）</p><p><code>SDWebImageImageIOCoder</code> ：内置编码器，支持PNG，JPEG，TIFF，支持逐行解码。该类遵守 <code>SDWebImageProgressiveCoder</code>协议。该协议也遵守<code>SDWebImageCoder</code>协议，所以这个类要实现这两个协议的方法。</p><p>  GIF<br>  还支持静态GIF（意思是只处理第一帧）。<br>  要获得完整的GIF支持，我们建议使用<code>FLAnimatedImage</code>或性能较差的<code>SDWebImageGIFCoder</code></p><p>  HEIC<br>  该编码器还支持HEIC格式，因为ImageIO本身支持它。但这取决于系统功能，因此无法在所有设备上运行。<a id="more"></a></p><h3 id="私有静态常量"><a href="#私有静态常量" class="headerlink" title="私有静态常量"></a>私有静态常量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//每像素字节数为4</span><br><span class="line">static const size_t kBytesPerPixel = 4;</span><br><span class="line">//每位字节数为8</span><br><span class="line">static const size_t kBitsPerComponent = 8;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">  *设置标志“SDWebImageScaleDownLargeImages”时，解码图像的最大大小（以MB为单位）</span><br><span class="line">  * iPad1和iPhone 3GS的建议值：60。</span><br><span class="line">  * iPad2和iPhone 4的建议值：120。</span><br><span class="line">  * iPhone 3G和iPod 2及早期设备的建议值：30。</span><br><span class="line"> */</span><br><span class="line">static const CGFloat kDestImageSizeMB = 60.0f;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *当设置标志“SDWebImageScaleDownLargeImages”时，定义用于解码图像的图块的最大大小（以MB为单位）</span><br><span class="line"> * iPad1和iPhone 3GS的建议值：20。</span><br><span class="line"> * iPad2和iPhone 4的建议值：40。</span><br><span class="line"> * iPhone 3G和iPod 2及早期设备的建议值：10。</span><br><span class="line">*/</span><br><span class="line">static const CGFloat kSourceImageTileSizeMB = 20.0f;</span><br><span class="line"></span><br><span class="line">//定义 1M = 1024.0f * 1024.0f</span><br><span class="line">static const CGFloat kBytesPerMB = 1024.0f * 1024.0f;</span><br><span class="line"></span><br><span class="line">//定义1MB的像素数是1MB的Bytes数量除以1像素的Bytes数</span><br><span class="line">static const CGFloat kPixelsPerMB = kBytesPerMB / kBytesPerPixel;</span><br><span class="line">//定义解码完的图像的最大像素总数数是解码完的图像最size乘以1MB的像素数</span><br><span class="line">static const CGFloat kDestTotalPixels = kDestImageSizeMB * kPixelsPerMB;</span><br><span class="line"></span><br><span class="line">//定义用于解码的图像的最大像素总数是解码的图像的size乘以1MB的像素数</span><br><span class="line">static const CGFloat kTileTotalPixels = kSourceImageTileSizeMB * kPixelsPerMB;</span><br><span class="line"></span><br><span class="line">//定义重叠像素大小为2像素</span><br><span class="line">static const CGFloat kDestSeemOverlap = 2.0f;</span><br></pre></td></tr></table></figure><h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        //定义了两个变量来保存图像的宽和高</span><br><span class="line">        size_t _width, _height;</span><br><span class="line">#if SD_UIKIT || SD_WATCH</span><br><span class="line">        //定义变量记录图片方向</span><br><span class="line">        UIImageOrientation _orientation;</span><br><span class="line">#endif</span><br><span class="line">        //定义变量记录图片源</span><br><span class="line">        CGImageSourceRef _imageSource;</span><br></pre></td></tr></table></figure><h3 id="life-cycle"><a href="#life-cycle" class="headerlink" title="life cycle"></a>life cycle</h3><p>单例方法和dealloc方法</p><p>C 语言不能够调用OC中的retain与release，一般的C 语言接口都提供了release函数（比如CGContextRelease(context c)）来管理内存。ARC不会自动调用这些C接口的函数，所以这还是需要我们自己来进行管理的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">    //如果CGImageSourceRef类型的_imageSource存在，在dealloc方法中手动释放掉（CGXXX 和CFXXX方法，ARC并不会自动释放，需要手动去释放掉）</span><br><span class="line">    </span><br><span class="line">    if (_imageSource) &#123;</span><br><span class="line">        CFRelease(_imageSource);</span><br><span class="line">        _imageSource = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//单例方法</span><br><span class="line">+ (instancetype)sharedCoder &#123;</span><br><span class="line">    static SDWebImageImageIOCoder *coder;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        coder = [[SDWebImageImageIOCoder alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><h4 id="SDWebImageCoder协议方法"><a href="#SDWebImageCoder协议方法" class="headerlink" title="SDWebImageCoder协议方法"></a><code>SDWebImageCoder</code>协议方法</h4><p>判断是否支持图片数据的解码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canDecodeFromData:(nullable NSData *)data &#123;</span><br><span class="line">    //通过NSData中的扩展方法：sd_imageFormatForImageData 获取图片的格式</span><br><span class="line">    switch ([NSData sd_imageFormatForImageData:data]) &#123;</span><br><span class="line">        case SDImageFormatWebP:</span><br><span class="line">            // 不支持WebP格式图片解码</span><br><span class="line">            return NO;</span><br><span class="line">        case SDImageFormatHEIC:</span><br><span class="line">            // 检查是否支持HEIC格式图片解码</span><br><span class="line">            return [[self class] canDecodeFromHEICFormat];</span><br><span class="line">        default:</span><br><span class="line">            return YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过图片数据（ImageData）解码获取图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)decodedImageWithData:(NSData *)data &#123;</span><br><span class="line">    //如果data为空，返回nil</span><br><span class="line">    if (!data) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //将imagedata转为图片</span><br><span class="line">    UIImage *image = [[UIImage alloc] initWithData:data];</span><br><span class="line">    //设置图片的格式</span><br><span class="line">    image.sd_imageFormat = [NSData sd_imageFormatForImageData:data];</span><br><span class="line">    </span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用原始图片和图片数据解压缩图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">使用原始图片和图片数据解压缩图片。</span><br><span class="line"></span><br><span class="line"> @param image 需要压缩的原图片</span><br><span class="line"> @param data 指向原始图像数据的指针。 指针本身是非空的，但图像数据可以为空。 如果需要，此数据将设置为缓存。 如果您不需要同时修改数据，请忽略此参数。</span><br><span class="line"> @param optionsDict 一个包含任何解压缩选项的字典。 通过&#123;SDWebImageCoderScaleDownLargeImagesKey：@（YES）&#125;缩小大图像</span><br><span class="line"> @return 解压缩后的图片</span><br><span class="line"> */</span><br><span class="line">- (UIImage *)decompressedImageWithImage:(UIImage *)image</span><br><span class="line">                                   data:(NSData *__autoreleasing  _Nullable *)data</span><br><span class="line">                                options:(nullable NSDictionary&lt;NSString*, NSObject*&gt;*)optionsDict &#123;</span><br><span class="line">                                </span><br><span class="line">//如果是mac，直接返回图片</span><br><span class="line">#if SD_MAC</span><br><span class="line">    return image;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">//如果是iOS 、osTV、osWatch</span><br><span class="line">#if SD_UIKIT || SD_WATCH</span><br><span class="line">    // 创建变量保存，默认是不缩小</span><br><span class="line">    BOOL shouldScaleDown = NO;</span><br><span class="line">    </span><br><span class="line">    // 如果传入选项字典参数</span><br><span class="line">    if (optionsDict != nil) &#123;</span><br><span class="line">        //创建临时变量保存选项值</span><br><span class="line">        NSNumber *scaleDownLargeImagesOption = nil;</span><br><span class="line">        //SDWebImageCoderScaleDownLargeImagesKey对应的value类型为NSNumber，则保存value</span><br><span class="line">        if ([optionsDict[SDWebImageCoderScaleDownLargeImagesKey] isKindOfClass:[NSNumber class]]) &#123;</span><br><span class="line">            scaleDownLargeImagesOption = (NSNumber *)optionsDict[SDWebImageCoderScaleDownLargeImagesKey];</span><br><span class="line">        &#125;</span><br><span class="line">        //如果选项值不为nil，转换成BOOL类型，并保存</span><br><span class="line">        if (scaleDownLargeImagesOption != nil) &#123;</span><br><span class="line">            shouldScaleDown = [scaleDownLargeImagesOption boolValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果不需要缩小图片，直接执行解压图片操作</span><br><span class="line">    if (!shouldScaleDown) &#123;</span><br><span class="line">        return [self sd_decompressedImageWithImage:image];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        如果需要缩小图片，则执行图片的解压和缩小操作</span><br><span class="line">        UIImage *scaledDownImage = [self sd_decompressedAndScaledDownImageWithImage:image];</span><br><span class="line">        </span><br><span class="line">         // 如果解压和缩小成功，仍处理数据指针，调用压缩方法</span><br><span class="line">        if (scaledDownImage &amp;&amp; !CGSizeEqualToSize(scaledDownImage.size, image.size)) &#123;</span><br><span class="line">            //根据图片数据指针得到图片的格式</span><br><span class="line">            SDImageFormat format = [NSData sd_imageFormatForImageData:*data];</span><br><span class="line">            //通过缩小的图片和图片格式编码获取imagedata</span><br><span class="line">            NSData *imageData = [self encodedDataWithImage:scaledDownImage format:format];</span><br><span class="line">            if (imageData) &#123;</span><br><span class="line">                // 通过参数回传处理后的图像数据</span><br><span class="line">                *data = imageData;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 返回处理后的图片</span><br><span class="line">        return scaledDownImage;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SDWebImageProgressiveCoder-协议方法"><a href="#SDWebImageProgressiveCoder-协议方法" class="headerlink" title="SDWebImageProgressiveCoder 协议方法"></a><code>SDWebImageProgressiveCoder</code> 协议方法</h4><p>判断是否支持增量解码某个data数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canIncrementallyDecodeFromData:(NSData *)data &#123;</span><br><span class="line">    //获取图片的格式</span><br><span class="line">    switch ([NSData sd_imageFormatForImageData:data]) &#123;</span><br><span class="line">        case SDImageFormatWebP:</span><br><span class="line">            // 不支持WebP逐行解码</span><br><span class="line">            return NO;</span><br><span class="line">        case SDImageFormatHEIC:</span><br><span class="line">            // 检查HEIC解码兼容性</span><br><span class="line">            return [[self class] canDecodeFromHEICFormat];</span><br><span class="line">        default:</span><br><span class="line">            // 其他类型就返回YES</span><br><span class="line">            return YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将图片数据增量解码为图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)incrementallyDecodedImageWithData:(NSData *)data finished:(BOOL)finished &#123;</span><br><span class="line">    判断增量图片源是否存在，如果不存在，创建一个新的</span><br><span class="line">    if (!_imageSource) &#123;</span><br><span class="line">        _imageSource = CGImageSourceCreateIncremental(NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    UIImage *image;</span><br><span class="line">    </span><br><span class="line">    //更新数据源，这里必须传递所有数据，而不仅仅是新字节</span><br><span class="line">    CGImageSourceUpdateData(_imageSource, (__bridge CFDataRef)data, finished);</span><br><span class="line">    </span><br><span class="line">    // 获取到图像的宽、高和方向</span><br><span class="line">    if (_width + _height == 0) &#123;</span><br><span class="line">        CFDictionaryRef properties = CGImageSourceCopyPropertiesAtIndex(_imageSource, 0, NULL);</span><br><span class="line">        if (properties) &#123;</span><br><span class="line">            NSInteger orientationValue = 1;</span><br><span class="line">            CFTypeRef val = CFDictionaryGetValue(properties, kCGImagePropertyPixelHeight);</span><br><span class="line">            if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;_height);</span><br><span class="line">            val = CFDictionaryGetValue(properties, kCGImagePropertyPixelWidth);</span><br><span class="line">            if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;_width);</span><br><span class="line">            val = CFDictionaryGetValue(properties, kCGImagePropertyOrientation);</span><br><span class="line">            if (val) CFNumberGetValue(val, kCFNumberNSIntegerType, &amp;orientationValue);</span><br><span class="line">            CFRelease(properties);</span><br><span class="line">            </span><br><span class="line">            //当我们绘制到Core Graphics时，我们会丢失方向信息，这意味着initWithCGIImage生成的图像有时会导致错误定向。 （与didCompleteWithError中的initWithData生成的图像不同。）因此将其保存在此处并稍后传递。</span><br><span class="line">#if SD_UIKIT || SD_WATCH</span><br><span class="line">            _orientation = [SDWebImageCoderHelper imageOrientationFromEXIFOrientation:orientationValue];</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (_width + _height &gt; 0) &#123;</span><br><span class="line">        // 创建位图对象</span><br><span class="line">        CGImageRef partialImageRef = CGImageSourceCreateImageAtIndex(_imageSource, 0, NULL);</span><br><span class="line">        </span><br><span class="line">        //如果存在，则根据该位图生成图片</span><br><span class="line">        if (partialImageRef) &#123;</span><br><span class="line">#if SD_UIKIT || SD_WATCH</span><br><span class="line">            image = [[UIImage alloc] initWithCGImage:partialImageRef scale:1 orientation:_orientation];</span><br><span class="line">#elif SD_MAC</span><br><span class="line">            image = [[UIImage alloc] initWithCGImage:partialImageRef size:NSZeroSize];</span><br><span class="line">#endif</span><br><span class="line">            // 位图对象的引用计数-1</span><br><span class="line">            CGImageRelease(partialImageRef);</span><br><span class="line">            image.sd_imageFormat = [NSData sd_imageFormatForImageData:data];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     // 如果加载完成就释放掉位图对象，并置空</span><br><span class="line">    if (finished) &#123;</span><br><span class="line">        if (_imageSource) &#123;</span><br><span class="line">            CFRelease(_imageSource);</span><br><span class="line">            _imageSource = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //返回该图片</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="私有方法中的：解压图片-和-解压并按比例缩小图片"><a href="#私有方法中的：解压图片-和-解压并按比例缩小图片" class="headerlink" title="私有方法中的：解压图片 和 解压并按比例缩小图片"></a>私有方法中的：解压图片 和 解压并按比例缩小图片</h4><p>解压图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#if SD_UIKIT || SD_WATCH</span><br><span class="line">- (nullable UIImage *)sd_decompressedImageWithImage:(nullable UIImage *)image &#123;</span><br><span class="line"></span><br><span class="line">    //如果图片不需要解码，直接返回image</span><br><span class="line">    if (![[self class] shouldDecodeImage:image]) &#123;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //自动释放位图上下文和所有变量以帮助系统在存在内存警告时释放内存。</span><br><span class="line">    //在iOS7上，别忘了调用[[SDImageCache sharedImageCache] clearMemory];</span><br><span class="line">    </span><br><span class="line">    // 建立自动释放池，以帮助系统在收到内存警告时释放内存。</span><br><span class="line">    @autoreleasepool&#123;</span><br><span class="line">        </span><br><span class="line">        //获取图片对象的位图图片</span><br><span class="line">        CGImageRef imageRef = image.CGImage;</span><br><span class="line">        // 获取图片对象的色彩空间</span><br><span class="line">        CGColorSpaceRef colorspaceRef = SDCGColorSpaceGetDeviceRGB();</span><br><span class="line">        BOOL hasAlpha = SDCGImageRefContainsAlpha(imageRef);</span><br><span class="line">        //  iOS 显示 Alpha（透明）信息  (BRGA8888/BGRX8888)</span><br><span class="line">        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line">        </span><br><span class="line">        size_t width = CGImageGetWidth(imageRef);</span><br><span class="line">        size_t height = CGImageGetHeight(imageRef);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        // CGBitmapContextCreate不支持kCGImageAlphaNone。由于此处的原始图像没有alpha信息，因此使用kCGImageAlphaNoneSkipLast创建没有alpha信息的位图图形上下文。</span><br><span class="line">        //创建位图图形上下文</span><br><span class="line">        CGContextRef context = CGBitmapContextCreate(NULL,</span><br><span class="line">                                                     width,</span><br><span class="line">                                                     height,</span><br><span class="line">                                                     kBitsPerComponent,</span><br><span class="line">                                                     0,</span><br><span class="line">                                                     colorspaceRef,</span><br><span class="line">                                                     bitmapInfo);</span><br><span class="line">        //如果创建失败，直接返回image</span><br><span class="line">        if (context == NULL) &#123;</span><br><span class="line">            return image;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 将图像绘制到上下文中并检索没有alpha的新位图图像</span><br><span class="line">        CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);</span><br><span class="line">        // 生成位图图像</span><br><span class="line">        CGImageRef imageRefWithoutAlpha = CGBitmapContextCreateImage(context);</span><br><span class="line">        // 根据位图图像生成图片对象</span><br><span class="line">        UIImage *imageWithoutAlpha = [[UIImage alloc] initWithCGImage:imageRefWithoutAlpha scale:image.scale orientation:image.imageOrientation];</span><br><span class="line">        //释放掉上下文</span><br><span class="line">        CGContextRelease(context);</span><br><span class="line">        //释放掉位图图片</span><br><span class="line">        CGImageRelease(imageRefWithoutAlpha);</span><br><span class="line">        </span><br><span class="line">        //返回位图图片</span><br><span class="line">        return imageWithoutAlpha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//解压并按比例缩小图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)sd_decompressedAndScaledDownImageWithImage:(nullable UIImage *)image &#123;</span><br><span class="line">    //如果图片不需要解码，直接返回image</span><br><span class="line">    if (![[self class] shouldDecodeImage:image]) &#123;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //如果图片不需要缩小，直接执行解压图片操作</span><br><span class="line">    if (![[self class] shouldScaleDownImage:image]) &#123;</span><br><span class="line">        return [self sd_decompressedImageWithImage:image];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 创建图像上下文</span><br><span class="line">    CGContextRef destContext;</span><br><span class="line">    </span><br><span class="line">    //自动释放位图上下文和所有变量以帮助系统在存在内存警告时释放内存。</span><br><span class="line">    //在iOS7上，别忘了调用[[SDImageCache sharedImageCache] clearMemory];</span><br><span class="line">    </span><br><span class="line">    // 建立自动释放池，以帮助系统在收到内存警告时释放内存</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        //获取图片对象的位图图片</span><br><span class="line">        CGImageRef sourceImageRef = image.CGImage;</span><br><span class="line">        </span><br><span class="line">        // 获取图像的总像素数</span><br><span class="line">        CGSize sourceResolution = CGSizeZero;</span><br><span class="line">        sourceResolution.width = CGImageGetWidth(sourceImageRef);</span><br><span class="line">        sourceResolution.height = CGImageGetHeight(sourceImageRef);</span><br><span class="line">        float sourceTotalPixels = sourceResolution.width * sourceResolution.height;</span><br><span class="line">        </span><br><span class="line">        // 计算缩小比例</span><br><span class="line">        float imageScale = kDestTotalPixels / sourceTotalPixels;</span><br><span class="line">        // 计算缩小后的尺寸</span><br><span class="line">        CGSize destResolution = CGSizeZero;</span><br><span class="line">        destResolution.width = (int)(sourceResolution.width*imageScale);</span><br><span class="line">        destResolution.height = (int)(sourceResolution.height*imageScale);</span><br><span class="line">        </span><br><span class="line">        // 获取色彩空间</span><br><span class="line">        CGColorSpaceRef colorspaceRef = SDCGColorSpaceGetDeviceRGB();</span><br><span class="line">        BOOL hasAlpha = SDCGImageRefContainsAlpha(sourceImageRef);</span><br><span class="line">        // iOS 显示 Alpha（透明）信息 (BGRA8888/BGRX8888)</span><br><span class="line">        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line">        </span><br><span class="line">        // CGBitmapContextCreate不支持kCGImageAlphaNone。由于此处的原始图像没有alpha信息，因此使用kCGImageAlphaNoneSkipLast创建没有alpha信息的位图图形上下文。</span><br><span class="line">        //创建位图图形上下文</span><br><span class="line">        destContext = CGBitmapContextCreate(NULL,</span><br><span class="line">                                            destResolution.width,</span><br><span class="line">                                            destResolution.height,</span><br><span class="line">                                            kBitsPerComponent,</span><br><span class="line">                                            0,</span><br><span class="line">                                            colorspaceRef,</span><br><span class="line">                                            bitmapInfo);</span><br><span class="line">        </span><br><span class="line">        //如果创建失败，直接返回image</span><br><span class="line">        if (destContext == NULL) &#123;</span><br><span class="line">            return image;</span><br><span class="line">        &#125;</span><br><span class="line">        // 设置图像上下文的绘图质量</span><br><span class="line">        CGContextSetInterpolationQuality(destContext, kCGInterpolationHigh);</span><br><span class="line">        </span><br><span class="line">        //现在定义用于从输入图像到输出图像的增量blit的矩形的大小。由于iOS从磁盘检索图像数据的方式，我们使用的源块宽度等于源图像的宽度。 iOS必须以全宽“波段”从磁盘解码图像，即使当前图形上下文被剪切为该波段内的子图形也是如此。 因此，我们通过将我们的图块大小设置为输入图像的整个宽度来充分利用由解码操作产生的所有像素数据。</span><br><span class="line">        </span><br><span class="line">        // 创建临时变量保存来源块大小</span><br><span class="line">        CGRect sourceTile = CGRectZero;</span><br><span class="line">        // 来源块的宽度就是原图的宽度</span><br><span class="line">        sourceTile.size.width = sourceResolution.width;</span><br><span class="line">        </span><br><span class="line">        // 源图块高度是动态的。 由于我们以MB为单位指定了源块的大小，因此请查看输入图像宽度可以为多少像素行。</span><br><span class="line">        // 计算来源块的高度</span><br><span class="line">        sourceTile.size.height = (int)(kTileTotalPixels / sourceTile.size.width );</span><br><span class="line">        // 设置来源块的X坐标</span><br><span class="line">        sourceTile.origin.x = 0.0f;</span><br><span class="line">        </span><br><span class="line">        //输出图块与输入图块的比例相同，但缩放为图像比例。</span><br><span class="line">        // 创建历史变量保存目标块大小</span><br><span class="line">        CGRect destTile;</span><br><span class="line">        </span><br><span class="line">        // 目标块的宽是缩放后的宽</span><br><span class="line">        destTile.size.width = destResolution.width;</span><br><span class="line">        </span><br><span class="line">        // 目标块的宽是来源块的高乘以缩放比</span><br><span class="line">        destTile.size.height = sourceTile.size.height * imageScale;</span><br><span class="line">        </span><br><span class="line">        // 设置目标块的X坐标</span><br><span class="line">        destTile.origin.x = 0.0f;</span><br><span class="line">        </span><br><span class="line">        //来源块与目标似乎重叠成比例。 这是我们组装输出图像时每个图块重叠的像素数量。</span><br><span class="line">        // 计算来源块与目标块的重复区域</span><br><span class="line">        float sourceSeemOverlap = (int)((kDestSeemOverlap/destResolution.height)*sourceResolution.height);</span><br><span class="line">        </span><br><span class="line">        // 生成变量保存来源块图像位图</span><br><span class="line">        CGImageRef sourceTileImageRef;</span><br><span class="line">        </span><br><span class="line">        // 计算组装输出图像所需的读/写操作次数。</span><br><span class="line">        // 计算需要绘制的次数</span><br><span class="line">        int iterations = (int)( sourceResolution.height / sourceTile.size.height );</span><br><span class="line">        </span><br><span class="line">        // 如果图块高度未均匀划分图像高度，请添加另一个迭代以考虑剩余像素。</span><br><span class="line">        // 计算剩余像素的高度</span><br><span class="line">        int remainder = (int)sourceResolution.height % (int)sourceTile.size.height;</span><br><span class="line">        </span><br><span class="line">        // 如果有剩余像素就将绘制次数加1</span><br><span class="line">        if(remainder) &#123;</span><br><span class="line">            iterations++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 添加似乎与切片重叠，但保存原始切片高度以进行y坐标计算。</span><br><span class="line">         // 创建变量保存来源块的高度，用来计算纵坐标的移动</span><br><span class="line">        float sourceTileHeightMinusOverlap = sourceTile.size.height;</span><br><span class="line">        </span><br><span class="line">        // 来源块高度加上要重复覆盖的高度</span><br><span class="line">        sourceTile.size.height += sourceSeemOverlap;</span><br><span class="line">        </span><br><span class="line">        // 目标块高度加上重叠的像素数</span><br><span class="line">        destTile.size.height += kDestSeemOverlap;</span><br><span class="line">        </span><br><span class="line">        // 开启循环绘制图像</span><br><span class="line">        for( int y = 0; y &lt; iterations; ++y ) &#123;</span><br><span class="line">            // 建立自动释放池，以帮助系统在收到内存警告时释放内存。</span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">                // 计算来源块的纵坐标：来源块的高度乘以当前循环次数，然后加上重复覆盖的高度</span><br><span class="line">                sourceTile.origin.y = y * sourceTileHeightMinusOverlap + sourceSeemOverlap;</span><br><span class="line">                </span><br><span class="line">                 // 计算目标块的纵坐标：目标图像的高度减去要绘制的来源块的高度乘以压缩比，再减去重叠高度</span><br><span class="line">                // 这个地方，来源块的纵坐标是递增的，目标块的纵坐标是递减的，这是因为为UIKit的坐标系和CGContext是镜像关系</span><br><span class="line">                destTile.origin.y = destResolution.height - (( y + 1 ) * sourceTileHeightMinusOverlap * imageScale + kDestSeemOverlap);</span><br><span class="line">                </span><br><span class="line">                // 按照计算好的尺寸绘制来源块的位图</span><br><span class="line">                sourceTileImageRef = CGImageCreateWithImageInRect( sourceImageRef, sourceTile );</span><br><span class="line">                </span><br><span class="line">                 // 如果是最后一块要绘制，并且这一块是剩余的像素</span><br><span class="line">                if( y == iterations - 1 &amp;&amp; remainder ) &#123;</span><br><span class="line">                </span><br><span class="line">                    // 因为剩余像素的高度是不固定的，所以重新计算目标块的纵坐标</span><br><span class="line">                    float dify = destTile.size.height;</span><br><span class="line">                    destTile.size.height = CGImageGetHeight( sourceTileImageRef ) * imageScale;</span><br><span class="line">                    dify -= destTile.size.height;</span><br><span class="line">                    destTile.origin.y += dify;</span><br><span class="line">                &#125;</span><br><span class="line">                // 将来源块位图按照计算好的尺寸绘制到目标图像上下文中</span><br><span class="line">                CGContextDrawImage( destContext, destTile, sourceTileImageRef );</span><br><span class="line">                </span><br><span class="line">                 // 释放来源块位图</span><br><span class="line">                CGImageRelease( sourceTileImageRef );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 根据目标图像上下文生成目标图像位图</span><br><span class="line">        CGImageRef destImageRef = CGBitmapContextCreateImage(destContext);</span><br><span class="line">        </span><br><span class="line">        // 释放目标图像上下文</span><br><span class="line">        CGContextRelease(destContext);</span><br><span class="line">        </span><br><span class="line">        // 如果生成位图失败就直接返回图片对象</span><br><span class="line">        if (destImageRef == NULL) &#123;</span><br><span class="line">            return image;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         // 生成目标图片对象</span><br><span class="line">        UIImage *destImage = [[UIImage alloc] initWithCGImage:destImageRef scale:image.scale orientation:image.imageOrientation];</span><br><span class="line">        </span><br><span class="line">         // 释放目标图像位图</span><br><span class="line">        CGImageRelease(destImageRef);</span><br><span class="line">        </span><br><span class="line">        // 如果生成图片对象失败就直接返回图片对象</span><br><span class="line">        if (destImage == nil) &#123;</span><br><span class="line">            return image;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 返回目标图片对象</span><br><span class="line">        return destImage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>判断某个图片格式是否支持编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//如果是WebP格式，则不支持编码；HEIC格式：根据canEncodeToHEICFormat方法判断是否支持编码；其他格式都支持编码</span><br><span class="line">- (BOOL)canEncodeToFormat:(SDImageFormat)format &#123;</span><br><span class="line">    switch (format) &#123;</span><br><span class="line">        case SDImageFormatWebP:</span><br><span class="line">            // 不支持WebP格式编码</span><br><span class="line">            return NO;</span><br><span class="line">        case SDImageFormatHEIC:</span><br><span class="line">            // 检查HEIC编码兼容性</span><br><span class="line">            return [[self class] canEncodeToHEICFormat];</span><br><span class="line">        default:</span><br><span class="line">            return YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将图片根据给定的格式解码成图片数据（imageData）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">- (NSData *)encodedDataWithImage:(UIImage *)image format:(SDImageFormat)format &#123;</span><br><span class="line">    //如果图片不存在，返回nil</span><br><span class="line">    if (!image) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //如果格式类型未识别，判断图片是否含有Alpha通道，如果有则定义为PNG格式，否则定义为JPEG格式</span><br><span class="line">    if (format == SDImageFormatUndefined) &#123;</span><br><span class="line">        BOOL hasAlpha = SDCGImageRefContainsAlpha(image.CGImage);</span><br><span class="line">        if (hasAlpha) &#123;</span><br><span class="line">            format = SDImageFormatPNG;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            format = SDImageFormatJPEG;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSMutableData *imageData = [NSMutableData data];</span><br><span class="line">    CFStringRef imageUTType = [NSData sd_UTTypeFromSDImageFormat:format];</span><br><span class="line">    </span><br><span class="line">    // 根据imageData 和 CFStringRef 创建 CGImageDestinationRef对象，如果创建失败，返回nil</span><br><span class="line">    CGImageDestinationRef imageDestination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData, imageUTType, 1, NULL);</span><br><span class="line">    if (!imageDestination) &#123;</span><br><span class="line">        // Handle failure.</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //创建字典对象保存编码参数</span><br><span class="line">    NSMutableDictionary *properties = [NSMutableDictionary dictionary];</span><br><span class="line">#if SD_UIKIT || SD_WATCH</span><br><span class="line">    //// 获取图片的方向</span><br><span class="line">    NSInteger exifOrientation = [SDWebImageCoderHelper exifOrientationFromImageOrientation:image.imageOrientation];</span><br><span class="line">    //设置方向参数</span><br><span class="line">    [properties setValue:@(exifOrientation) forKey:(__bridge NSString *)kCGImagePropertyOrientation];</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    // 添加图片位图对象到创建的CGImageDestinationRef对象中</span><br><span class="line">    CGImageDestinationAddImage(imageDestination, image.CGImage, (__bridge CFDictionaryRef)properties);</span><br><span class="line">    </span><br><span class="line">    // 如果编码失败就返回空</span><br><span class="line">    if (CGImageDestinationFinalize(imageDestination) == NO) &#123;</span><br><span class="line">        // Handle failure.</span><br><span class="line">        imageData = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //释放掉imageDestination对象</span><br><span class="line">    CFRelease(imageDestination);</span><br><span class="line">    </span><br><span class="line">    //返回</span><br><span class="line">    return [imageData copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="私有方法（辅助方法）"><a href="#私有方法（辅助方法）" class="headerlink" title="私有方法（辅助方法）"></a>私有方法（辅助方法）</h3><ol><li>是否需要解压图片<br>（如果图片为动图或不存在，不解压图片，否则解压图片）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)shouldDecodeImage:(nullable UIImage *)image &#123;</span><br><span class="line">    //如果图片为空，返回NO</span><br><span class="line">    if (image == nil) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 如果图片为动图，返回NO</span><br><span class="line">    if (image.images != nil) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    否则返回YES</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>是否支持<code>HEIC</code>格式类型的图片解码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)canDecodeFromHEICFormat &#123;</span><br><span class="line">    //临时静态变量 canDecode 为 NO</span><br><span class="line">    static BOOL canDecode = NO;</span><br><span class="line">    </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    </span><br><span class="line">//忽略-Wunguarded-availability警告   </span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wunguarded-availability&quot;</span><br><span class="line"></span><br><span class="line">//如果是iWatch 或者 SIMULATOR ，则不支持</span><br><span class="line">#if TARGET_OS_SIMULATOR || SD_WATCH  //iWatch</span><br><span class="line">        canDecode = NO;</span><br><span class="line">        </span><br><span class="line">#elif SD_MAC  //mac</span><br><span class="line">        </span><br><span class="line">        //获取进程信息对象</span><br><span class="line">        NSProcessInfo *processInfo = [NSProcessInfo processInfo];</span><br><span class="line">        if ([processInfo respondsToSelector:@selector(operatingSystemVersion)]) &#123;</span><br><span class="line">            //通过进程信息对象获取操作系统版本。判断macOS系统版本10.13+，则支持HEIC类型图像的解码</span><br><span class="line">            canDecode = processInfo.operatingSystemVersion.minorVersion &gt;= 13;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            canDecode = NO;</span><br><span class="line">        &#125;</span><br><span class="line">#elif SD_UIKIT //iOS 和 tvOS</span><br><span class="line">        //获取进程信息对象</span><br><span class="line">        NSProcessInfo *processInfo = [NSProcessInfo processInfo];</span><br><span class="line">        if ([processInfo respondsToSelector:@selector(operatingSystemVersion)]) &#123;</span><br><span class="line">            //通过进程信息对象获取操作系统版本。判断操作系统版本是iOS 11+就支持HEIC类型图像的解码</span><br><span class="line">            canDecode = processInfo.operatingSystemVersion.majorVersion &gt;= 11;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            canDecode = NO;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">    &#125;);</span><br><span class="line">    return canDecode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>是否支持<code>HEIC</code>格式类型的图片编码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)canEncodeToHEICFormat &#123;</span><br><span class="line">    //临时静态变量 canDecode 为 NO</span><br><span class="line">    static BOOL canEncode = NO;</span><br><span class="line">    </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        NSMutableData *imageData = [NSMutableData data];</span><br><span class="line">        CFStringRef imageUTType = [NSData sd_UTTypeFromSDImageFormat:SDImageFormatHEIC];</span><br><span class="line">        </span><br><span class="line">        // 创建一个CGImageDestinationRef对象，如果该对象可以创建成功，则需要编码，否则不需要</span><br><span class="line">        CGImageDestinationRef imageDestination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData, imageUTType, 1, NULL);</span><br><span class="line">        if (!imageDestination) &#123;</span><br><span class="line">            // Can&apos;t encode to HEIC</span><br><span class="line">            canEncode = NO;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Can encode to HEIC</span><br><span class="line">            CFRelease(imageDestination);</span><br><span class="line">            canEncode = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return canEncode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>是否应该缩小图片</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#if SD_UIKIT || SD_WATCH</span><br><span class="line">+ (BOOL)shouldScaleDownImage:(nonnull UIImage *)image &#123;</span><br><span class="line">    BOOL shouldScaleDown = YES;</span><br><span class="line">    </span><br><span class="line">    //获取图片的位图图像</span><br><span class="line">    CGImageRef sourceImageRef = image.CGImage;</span><br><span class="line">    </span><br><span class="line">    //获取到位图图像的宽和高</span><br><span class="line">    CGSize sourceResolution = CGSizeZero;</span><br><span class="line">    sourceResolution.width = CGImageGetWidth(sourceImageRef);</span><br><span class="line">    sourceResolution.height = CGImageGetHeight(sourceImageRef);</span><br><span class="line">    </span><br><span class="line">    //计算图片的总像素数</span><br><span class="line">    float sourceTotalPixels = sourceResolution.width * sourceResolution.height;</span><br><span class="line">    </span><br><span class="line">    //图片的压缩比： 最大像素数 / 图片的总像素数</span><br><span class="line">    float imageScale = kDestTotalPixels / sourceTotalPixels;</span><br><span class="line">    </span><br><span class="line">    //如果压缩比小于1，返回YES，否则返回NO</span><br><span class="line">    if (imageScale &lt; 1) &#123;</span><br><span class="line">        shouldScaleDown = YES;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        shouldScaleDown = NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return shouldScaleDown;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;SDWebImage&lt;/code&gt; 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（&lt;code&gt;SDWebImageCodersManager&lt;/code&gt;）、编解码协议（&lt;code&gt;SDWebImageCoder&lt;/code&gt;）、PNG/JPEG/TIFF编解码，解压缩，显示大图（&lt;code&gt;SDWebImageImageIOCoder&lt;/code&gt;）、GIF编解码（&lt;code&gt;SDWebImageGIFCoder&lt;/code&gt;）、WebP编解码（&lt;code&gt;SDWebImageWebPCoder&lt;/code&gt;）以及辅助类（&lt;code&gt;SDWebImageCoderHelper&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SDWebImageImageIOCoder&lt;/code&gt; ：内置编码器，支持PNG，JPEG，TIFF，支持逐行解码。该类遵守 &lt;code&gt;SDWebImageProgressiveCoder&lt;/code&gt;协议。该协议也遵守&lt;code&gt;SDWebImageCoder&lt;/code&gt;协议，所以这个类要实现这两个协议的方法。&lt;/p&gt;
&lt;p&gt;  GIF&lt;br&gt;  还支持静态GIF（意思是只处理第一帧）。&lt;br&gt;  要获得完整的GIF支持，我们建议使用&lt;code&gt;FLAnimatedImage&lt;/code&gt;或性能较差的&lt;code&gt;SDWebImageGIFCoder&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  HEIC&lt;br&gt;  该编码器还支持HEIC格式，因为ImageIO本身支持它。但这取决于系统功能，因此无法在所有设备上运行。
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 六 （编码器三：SDWebImageCodersManager）</title>
    <link href="http://guohuaden.com/2018/10/18/Read-SDWebImage-SDWebImageCodersManager/"/>
    <id>http://guohuaden.com/2018/10/18/Read-SDWebImage-SDWebImageCodersManager/</id>
    <published>2018-10-18T12:48:55.000Z</published>
    <updated>2018-10-29T09:59:10.285Z</updated>
    
    <content type="html"><![CDATA[<p><code>SDWebImage</code> 内部实现了一个图片解码/编码的图片编解码器，用于图片的编解码、压缩。其中涉及到编解码管理（<code>SDWebImageCodersManager</code>）、编解码协议（<code>SDWebImageCoder</code>）、PNG/JPEG/TIFF编解码，解压缩，显示大图（<code>SDWebImageImageIOCoder</code>）、GIF编解码（<code>SDWebImageGIFCoder</code>）、WebP编解码（<code>SDWebImageWebPCoder</code>）以及辅助类（<code>SDWebImageCoderHelper</code>）</p><h3 id="编解码管理（-SDWebImageCodersManager-）"><a href="#编解码管理（-SDWebImageCodersManager-）" class="headerlink" title="编解码管理（ SDWebImageCodersManager ）"></a>编解码管理（ <code>SDWebImageCodersManager</code> ）</h3><p>编解码管理器，整体编解码器的入口，该类遵守了 <code>SDWebImageCoder</code> 协议，说明这个类可以提供基本的编解码功能 。编解码器数组是一个优先级队列，也意味着处理多个图片编解码任务时新添加的编解码器将具有最高优先级（即被先调用）<a id="more"></a></p><h4 id="声明属性和方法"><a href="#声明属性和方法" class="headerlink" title="声明属性和方法"></a>声明属性和方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 单例初始化</span><br><span class="line"> */</span><br><span class="line">+ (nonnull instancetype)sharedInstance;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 所有的编解码器都在这个编解码器管理中（编码器数组）这个编解码器数组是一个优先级对列, 这意味着最后添加的编解码器拥有最高的优先级</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, copy, readwrite, nullable) NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 在编解码器数组的末尾添加一个新的编解码器。 新添加的编解码器优先级最高。</span><br><span class="line"></span><br><span class="line"> @param coder 需添加的coder</span><br><span class="line"> */</span><br><span class="line">- (void)addCoder:(nonnull id&lt;SDWebImageCoder&gt;)coder;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 在编解码器数组中移除编码器</span><br><span class="line"></span><br><span class="line"> @param coder 需移除的coder</span><br><span class="line"> */</span><br><span class="line">- (void)removeCoder:(nonnull id&lt;SDWebImageCoder&gt;)coder;</span><br></pre></td></tr></table></figure><h4 id="初始化方法实现"><a href="#初始化方法实现" class="headerlink" title="初始化方法实现"></a>初始化方法实现</h4><p>初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//单例</span><br><span class="line">+ (nonnull instancetype)sharedInstance &#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    static id instance;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">        instance = [self new];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        // 初始化默认的编解码器，默认编码器只有SDWebImageImageIOCoder类型的</span><br><span class="line">        NSMutableArray&lt;id&lt;SDWebImageCoder&gt;&gt; *mutableCoders = [@[[SDWebImageImageIOCoder sharedCoder]] mutableCopy];</span><br><span class="line">#ifdef SD_WEBP</span><br><span class="line">        //如果是WEBP，就添加SDWebImageWebPCoder单例</span><br><span class="line">        [mutableCoders addObject:[SDWebImageWebPCoder sharedCoder]];</span><br><span class="line">#endif</span><br><span class="line">        _coders = [mutableCoders copy];</span><br><span class="line">        _codersLock = dispatch_semaphore_create(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编码器IO操作"><a href="#编码器IO操作" class="headerlink" title="编码器IO操作"></a>编码器IO操作</h4><p>添加编码器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)addCoder:(nonnull id&lt;SDWebImageCoder&gt;)coder &#123;</span><br><span class="line">    //判断要添加的编解码器是否遵守SDWebImageCoder协议，以提供最基本的编解码功能</span><br><span class="line">    //如果不遵守SDWebImageCoder协议，返回</span><br><span class="line">    if (![coder conformsToProtocol:@protocol(SDWebImageCoder)]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    LOCK(self.codersLock);</span><br><span class="line">    //临时变量，编解码器数组，如果不存在，重新初始化一个</span><br><span class="line">    NSMutableArray&lt;id&lt;SDWebImageCoder&gt;&gt; *mutableCoders = [self.coders mutableCopy];</span><br><span class="line">    if (!mutableCoders) &#123;</span><br><span class="line">        mutableCoders = [NSMutableArray array];</span><br><span class="line">    &#125;</span><br><span class="line">    //添加新的coder</span><br><span class="line">    [mutableCoders addObject:coder];</span><br><span class="line">    //重新赋值给self.coders</span><br><span class="line">    self.coders = [mutableCoders copy];</span><br><span class="line">    UNLOCK(self.codersLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移除编码器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeCoder:(nonnull id&lt;SDWebImageCoder&gt;)coder &#123;</span><br><span class="line">    //判断要添加的编解码器是否遵守SDWebImageCoder协议，以提供最基本的编解码功能</span><br><span class="line">    //如果不遵守SDWebImageCoder协议，返回</span><br><span class="line">    if (![coder conformsToProtocol:@protocol(SDWebImageCoder)]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    LOCK(self.codersLock);</span><br><span class="line">    //临时变量，编解码器数组，使其等于self.coders（深拷贝）</span><br><span class="line">    NSMutableArray&lt;id&lt;SDWebImageCoder&gt;&gt; *mutableCoders = [self.coders mutableCopy];</span><br><span class="line">    //移除编解码器coder</span><br><span class="line">    [mutableCoders removeObject:coder];</span><br><span class="line">     //重新赋值给self.coders</span><br><span class="line">    self.coders = [mutableCoders copy];</span><br><span class="line">    UNLOCK(self.codersLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SDWebImageCoder协议方法实现"><a href="#SDWebImageCoder协议方法实现" class="headerlink" title="SDWebImageCoder协议方法实现"></a>SDWebImageCoder协议方法实现</h4><p>解码协议实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 如果此编解码器可以解码某些data，返回YES，否则，它应该传递给另一个编码器</span><br><span class="line"> </span><br><span class="line"> @param data 需要解码的图片数据</span><br><span class="line"> @return 如果此编解码器可以解码图片数据，返回YES，否则返回NO</span><br><span class="line"> */</span><br><span class="line">- (BOOL)canDecodeFromData:(NSData *)data &#123;</span><br><span class="line">    LOCK(self.codersLock);</span><br><span class="line">    //临时变量，编解码器数组，赋值等于 self.coders</span><br><span class="line">    NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders = self.coders;</span><br><span class="line">    UNLOCK(self.codersLock);</span><br><span class="line">    //倒序遍历编解码器数组（倒序的原因是：编解码器数组中最新添加的具有最高优先级）</span><br><span class="line">    for (id&lt;SDWebImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123;</span><br><span class="line">        //判断，如果其中有编解码器能够解码，就返回YES，否则返回NO</span><br><span class="line">        if ([coder canDecodeFromData:data]) &#123;</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 将图片数据解码为图片。</span><br><span class="line"> </span><br><span class="line"> @param data 需要解码的图片数据</span><br><span class="line"> @return 解码后得到的图片</span><br><span class="line"> */</span><br><span class="line">- (UIImage *)decodedImageWithData:(NSData *)data &#123;</span><br><span class="line">    LOCK(self.codersLock);</span><br><span class="line">    NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders = self.coders;</span><br><span class="line">    UNLOCK(self.codersLock);</span><br><span class="line">    //倒序遍历编解码器列表</span><br><span class="line">    for (id&lt;SDWebImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123;</span><br><span class="line">        //判断，如果其中有编解码器能够解码，就执行解码操作，否则返回Image为nil</span><br><span class="line">        if ([coder canDecodeFromData:data]) &#123;</span><br><span class="line">            return [coder decodedImageWithData:data];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">使用原始图片和图片数据解压缩图片。</span><br><span class="line"></span><br><span class="line"> @param image 需要压缩的原图片</span><br><span class="line"> @param data 指向原始图像数据的指针。 指针本身是非空的，但图像数据可以为空。 如果需要，此数据将设置为缓存。 如果您不需要同时修改数据，请忽略此参数。</span><br><span class="line"> @param optionsDict 一个包含任何解压缩选项的字典。 通过&#123;SDWebImageCoderScaleDownLargeImagesKey：@（YES）&#125;缩小大图像</span><br><span class="line"> @return 解压缩后的图片</span><br><span class="line"> */</span><br><span class="line">- (UIImage *)decompressedImageWithImage:(UIImage *)image</span><br><span class="line">                                   data:(NSData *__autoreleasing  _Nullable *)data</span><br><span class="line">                                options:(nullable NSDictionary&lt;NSString*, NSObject*&gt;*)optionsDict &#123;</span><br><span class="line">    //如果image不存在，返回nil</span><br><span class="line">    if (!image) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    LOCK(self.codersLock);</span><br><span class="line">    NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders = self.coders;</span><br><span class="line">    UNLOCK(self.codersLock);</span><br><span class="line">    //倒序遍历编解码器列表</span><br><span class="line">    for (id&lt;SDWebImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123;</span><br><span class="line">        //如果其中有编解码器可以解码，执行解压缩图片操作，并返回解压缩后的图片</span><br><span class="line">        if ([coder canDecodeFromData:*data]) &#123;</span><br><span class="line">            //解压缩图片操作</span><br><span class="line">            UIImage *decompressedImage = [coder decompressedImageWithImage:image data:data options:optionsDict];</span><br><span class="line">            decompressedImage.sd_imageFormat = image.sd_imageFormat;</span><br><span class="line">            return decompressedImage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编码协议实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 如果此编码器可以编码某些图片格式，返回YES，否则，它应该传递给另一个编码器</span><br><span class="line"> </span><br><span class="line"> @param format 图片格式</span><br><span class="line"> @return 如果此编码器可以编码图片格式，返回YES，否则返回NO</span><br><span class="line"> */</span><br><span class="line">- (BOOL)canEncodeToFormat:(SDImageFormat)format &#123;</span><br><span class="line">    LOCK(self.codersLock);</span><br><span class="line">    NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders = self.coders;</span><br><span class="line">    UNLOCK(self.codersLock);</span><br><span class="line">    //倒序遍历编解码器列表</span><br><span class="line">    for (id&lt;SDWebImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123;</span><br><span class="line">        //判断，如果其中有编解码器能够编码图片格式，就返回YES，否则返回NO</span><br><span class="line">        if ([coder canEncodeToFormat:format]) &#123;</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 将图片编码为图片数据（imagedata）</span><br><span class="line"></span><br><span class="line"> @param image 需要编码的图片</span><br><span class="line"> @param format 要编码的图片格式, 也有可能是 `SDImageFormatUndefined` 格式（未识别格式）</span><br><span class="line"> @return The encoded image data</span><br><span class="line"> */</span><br><span class="line">- (NSData *)encodedDataWithImage:(UIImage *)image format:(SDImageFormat)format &#123;</span><br><span class="line">    //如果image不存在，返回nil</span><br><span class="line">    if (!image) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    LOCK(self.codersLock);</span><br><span class="line">    NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders = self.coders;</span><br><span class="line">    UNLOCK(self.codersLock);</span><br><span class="line">    //倒序遍历编解码器列表</span><br><span class="line">    for (id&lt;SDWebImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123;</span><br><span class="line">        //判断，如果其中有编解码器能够编码图片格式，就执行将图片以format格式编码为data操作，并返回imagedata</span><br><span class="line">        if ([coder canEncodeToFormat:format]) &#123;</span><br><span class="line">            // 将图片编码为图片数据（imagedata）</span><br><span class="line">            return [coder encodedDataWithImage:image format:format];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;SDWebImage&lt;/code&gt; 内部实现了一个图片解码/编码的图片编解码器，用于图片的编解码、压缩。其中涉及到编解码管理（&lt;code&gt;SDWebImageCodersManager&lt;/code&gt;）、编解码协议（&lt;code&gt;SDWebImageCoder&lt;/code&gt;）、PNG/JPEG/TIFF编解码，解压缩，显示大图（&lt;code&gt;SDWebImageImageIOCoder&lt;/code&gt;）、GIF编解码（&lt;code&gt;SDWebImageGIFCoder&lt;/code&gt;）、WebP编解码（&lt;code&gt;SDWebImageWebPCoder&lt;/code&gt;）以及辅助类（&lt;code&gt;SDWebImageCoderHelper&lt;/code&gt;）&lt;/p&gt;
&lt;h3 id=&quot;编解码管理（-SDWebImageCodersManager-）&quot;&gt;&lt;a href=&quot;#编解码管理（-SDWebImageCodersManager-）&quot; class=&quot;headerlink&quot; title=&quot;编解码管理（ SDWebImageCodersManager ）&quot;&gt;&lt;/a&gt;编解码管理（ &lt;code&gt;SDWebImageCodersManager&lt;/code&gt; ）&lt;/h3&gt;&lt;p&gt;编解码管理器，整体编解码器的入口，该类遵守了 &lt;code&gt;SDWebImageCoder&lt;/code&gt; 协议，说明这个类可以提供基本的编解码功能 。编解码器数组是一个优先级队列，也意味着处理多个图片编解码任务时新添加的编解码器将具有最高优先级（即被先调用）
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage  六 （编码器二：SDWebImageCoderHelper  以及动图处理使用到的 SDWebImageFrame）</title>
    <link href="http://guohuaden.com/2018/10/15/Read-SDWebImage-SDWebImageCoderHelper/"/>
    <id>http://guohuaden.com/2018/10/15/Read-SDWebImage-SDWebImageCoderHelper/</id>
    <published>2018-10-15T13:52:22.000Z</published>
    <updated>2018-10-26T02:52:32.450Z</updated>
    
    <content type="html"><![CDATA[<p><code>SDWebImage</code> 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（<code>SDWebImageCodersManager</code>）、编解码协议（<code>SDWebImageCoder</code>）、PNG/JPEG/TIFF编解码，解压缩，显示大图（<code>SDWebImageImageIOCoder</code>）、GIF编解码（<code>SDWebImageGIFCoder</code>）、WebP编解码（<code>SDWebImageWebPCoder</code>）以及辅助类（<code>SDWebImageCoderHelper</code>）</p><p>本篇只做 <code>SDWebImageCoderHelper</code> 类的分析。该类作为辅助类，主要实现了两个功能：动图处理 和 图片方向处理。每个功能有两种方法，均为互逆方法。</p><a id="more"></a><h4 id="SDWebImageFrame类对象"><a href="#SDWebImageFrame类对象" class="headerlink" title="SDWebImageFrame类对象"></a><code>SDWebImageFrame</code>类对象</h4><p>在动图处理期间，使用到了 <code>SDWebImageFrame</code> 对象，该对象是使用单独的类实现的，在GIF等动态图使用中作为每一帧的显示作用。该类用于通过<code>SDWebImageCoderHelper</code>中的<code>animatedImageWithFrames</code>创建动画图片。 如果需要指定动画图片循环计数，请在“UIImage + MultiFormat”中使用<code>sd_imageLoopCount</code>属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 当前帧的图片</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, strong, readonly, nonnull) UIImage *image;</span><br><span class="line">/**</span><br><span class="line">要显示的当前帧的持续时间。 数字是秒而不是毫秒。不应将此值设置为零。</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, readonly, assign) NSTimeInterval duration;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">使用指定图片和持续时间创建框架实例</span><br><span class="line"></span><br><span class="line"> @param image 当前帧的图片</span><br><span class="line"> @param duration 当前帧的持续时间</span><br><span class="line"> @return 返回框架实例</span><br><span class="line"> */</span><br><span class="line">+ (instancetype _Nonnull)frameWithImage:(UIImage * _Nonnull)image duration:(NSTimeInterval)duration;</span><br></pre></td></tr></table></figure><p>初始化方法实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)frameWithImage:(UIImage *)image duration:(NSTimeInterval)duration &#123;</span><br><span class="line">    SDWebImageFrame *frame = [[SDWebImageFrame alloc] init];</span><br><span class="line">    frame.image = image;</span><br><span class="line">    frame.duration = duration;</span><br><span class="line">    </span><br><span class="line">    return frame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动图处理"><a href="#动图处理" class="headerlink" title="动图处理"></a>动图处理</h4><p>根据SDWebImageFrame帧数组返回动图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 根据SDWebImageFrame帧数组返回动图</span><br><span class="line">  对于UIKit，这将应用补丁，然后创建动画UIImage。 补丁是因为`+ [UIImage animatedImageWithImages：duration：]`只使用每个图片的平均持续时间。 因此，如果不同的帧具有不同的持续时间，则不起作用 因此，我们重复指定帧的指定帧以使其工作。</span><br><span class="line">  对于AppKit，NSImage不支持GIF以外的动画。 这将尝试将帧编码为GIF格式，然后创建用于渲染的动画NSImage。 注意，如果输入帧包含完整的Alpha通道，动画图片可能会丢失一些细节，因为GIF仅支持1位alpha通道。 （1个像素，透明或不透明）</span><br><span class="line"></span><br><span class="line"> @param frames SDWebImageFrame帧数组. 如果数组为空或者nil，返回nil</span><br><span class="line"> @return 用于在UIImageView（UIKit）或NSImageView（AppKit）上渲染的动画图片</span><br><span class="line"> */</span><br><span class="line">+ (UIImage * _Nullable)animatedImageWithFrames:(NSArray&lt;SDWebImageFrame *&gt; * _Nullable)frames;</span><br></pre></td></tr></table></figure><p>方法实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">+ (UIImage *)animatedImageWithFrames:(NSArray&lt;SDWebImageFrame *&gt; *)frames &#123;</span><br><span class="line">  //如果数组元素为空，返回动图为nil</span><br><span class="line">    NSUInteger frameCount = frames.count;</span><br><span class="line">    if (frameCount == 0) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">     // 生成临时变量保存动图</span><br><span class="line">    UIImage *animatedImage;</span><br><span class="line">  </span><br><span class="line">//如果是iOS 、iWatch 、 Apple TV  </span><br><span class="line">#if SD_UIKIT || SD_WATCH </span><br><span class="line">    //生成一个元素类型为非负整数，长度为动图帧数的数组个数，保存每一帧的展示时间</span><br><span class="line">    NSUInteger durations[frameCount];</span><br><span class="line">    for (size_t i = 0; i &lt; frameCount; i++) &#123;</span><br><span class="line">        //遍历SDWebImageFrame对象数组，获取每一帧的展示时间</span><br><span class="line">        durations[i] = frames[i].duration * 1000;</span><br><span class="line">    &#125;</span><br><span class="line">    计算所有帧展示时长的最大公约数</span><br><span class="line">    NSUInteger const gcd = gcdArray(frameCount, durations);</span><br><span class="line">    //临时变量保存总时长</span><br><span class="line">    __block NSUInteger totalDuration = 0;</span><br><span class="line">    //创建一个可变数组，长度为动图帧数的数组个数</span><br><span class="line">    NSMutableArray&lt;UIImage *&gt; *animatedImages = [NSMutableArray arrayWithCapacity:frameCount];</span><br><span class="line">    //遍历传入的动图帧数的数组</span><br><span class="line">    [frames enumerateObjectsUsingBlock:^(SDWebImageFrame * _Nonnull frame, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        // 获取SDWebImageFrame对象保存的每一帧的图像</span><br><span class="line">        UIImage *image = frame.image;</span><br><span class="line">        // 获取SDWebImageFrame对象保存的每一帧的展示时间</span><br><span class="line">        NSUInteger duration = frame.duration * 1000;</span><br><span class="line">        //总时长</span><br><span class="line">        totalDuration += duration;</span><br><span class="line">        //临时变量，保存重复次数</span><br><span class="line">        NSUInteger repeatCount;</span><br><span class="line">        // 如果计算出的最大公约数大于零，每一帧的重复次数就是展示时间除以最大公约数</span><br><span class="line">        // 否则每一帧只重复一次，也就说不重复</span><br><span class="line">        if (gcd) &#123;</span><br><span class="line">            repeatCount = duration / gcd;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            repeatCount = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 根据重复次数向动图数组中重复添加同一帧</span><br><span class="line">        for (size_t i = 0; i &lt; repeatCount; ++i) &#123;</span><br><span class="line">            [animatedImages addObject:image];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    获得动图</span><br><span class="line">    animatedImage = [UIImage animatedImageWithImages:animatedImages duration:totalDuration / 1000.f];</span><br><span class="line">    </span><br><span class="line">#else //如果不是（iOS 、iWatch 、 Apple TV ）</span><br><span class="line">    </span><br><span class="line">    NSMutableData *imageData = [NSMutableData data];</span><br><span class="line">    CFStringRef imageUTType = [NSData sd_UTTypeFromSDImageFormat:SDImageFormatGIF];</span><br><span class="line">    // 创建图像目标。 GIF不支持EXIF图像方向</span><br><span class="line">    CGImageDestinationRef imageDestination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData, imageUTType, frameCount, NULL);</span><br><span class="line">    if (!imageDestination) &#123;</span><br><span class="line">        // 处理失败。</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //遍历传入的动图帧数的数组</span><br><span class="line">    for (size_t i = 0; i &lt; frameCount; i++) &#123;</span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            // 获取SDWebImageFrame对象保存的每一帧的图像</span><br><span class="line">            SDWebImageFrame *frame = frames[i];</span><br><span class="line">            // 获取SDWebImageFrame对象保存的每一帧的展示时间</span><br><span class="line">            float frameDuration = frame.duration;</span><br><span class="line">            </span><br><span class="line">            CGImageRef frameImageRef = frame.image.CGImage;</span><br><span class="line">            NSDictionary *frameProperties = @&#123;(__bridge NSString *)kCGImagePropertyGIFDictionary : @&#123;(__bridge NSString *)kCGImagePropertyGIFDelayTime : @(frameDuration)&#125;&#125;;</span><br><span class="line">            CGImageDestinationAddImage(imageDestination, frameImageRef, (__bridge CFDictionaryRef)frameProperties);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Finalize the destination.</span><br><span class="line">    if (CGImageDestinationFinalize(imageDestination) == NO) &#123;</span><br><span class="line">        // 处理失败。</span><br><span class="line">        CFRelease(imageDestination);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    CFRelease(imageDestination);</span><br><span class="line">    SDAnimatedImageRep *imageRep = [[SDAnimatedImageRep alloc] initWithData:imageData];</span><br><span class="line">    animatedImage = [[NSImage alloc] initWithSize:imageRep.size];</span><br><span class="line">    [animatedImage addRepresentation:imageRep];</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    return animatedImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据动图返回SDWebImageFrame帧数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 根据动图返回SDWebImageFrame帧数组</span><br><span class="line">对于UIKit，这将取消应用上述描述的补丁，然后创建frames数组。 这也适用于普通的动画UIImage。</span><br><span class="line">  对于AppKit，NSImage不支持GIF以外的动画。 这将尝试解码GIF imageRep，然后创建帧数组。</span><br><span class="line"></span><br><span class="line"> @param animatedImage 一个动图.如果不是动图，返回nil</span><br><span class="line"> @return 返回SDWebImageFrame帧数组</span><br><span class="line"> */</span><br><span class="line">+ (NSArray&lt;SDWebImageFrame *&gt; * _Nullable)framesFromAnimatedImage:(UIImage * _Nullable)animatedImage;</span><br></pre></td></tr></table></figure><p>方法实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">+ (NSArray&lt;SDWebImageFrame *&gt; *)framesFromAnimatedImage:(UIImage *)animatedImage &#123;</span><br><span class="line">    //如果动图不存在，返回nil</span><br><span class="line">    if (!animatedImage) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //初始化两个临时变量： SDWebImageFrame对象 和帧个数</span><br><span class="line">    NSMutableArray&lt;SDWebImageFrame *&gt; *frames = [NSMutableArray array];</span><br><span class="line">    NSUInteger frameCount = 0;</span><br><span class="line">    </span><br><span class="line">#if SD_UIKIT || SD_WATCH</span><br><span class="line">    //获取动图的帧图片数组</span><br><span class="line">    NSArray&lt;UIImage *&gt; *animatedImages = animatedImage.images;</span><br><span class="line">    //获取动图的帧图片数量</span><br><span class="line">    frameCount = animatedImages.count;</span><br><span class="line">    //如果帧图片数量为0，表示不是动图，返回nil</span><br><span class="line">    if (frameCount == 0) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    //计算每一帧的平均展示时间</span><br><span class="line">    NSTimeInterval avgDuration = animatedImage.duration / frameCount;</span><br><span class="line">    //如果这个动图没有展示时间就默认每一帧展示100毫秒 ，即0.1秒（这没有像GIF或WebP那样的10ms限制，以允许自定义编码器提供限制）</span><br><span class="line">    if (avgDuration == 0) &#123;</span><br><span class="line">        avgDuration = 0.1; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 记录不同帧图片的数量</span><br><span class="line">    __block NSUInteger index = 0;</span><br><span class="line">    //记录一帧图片重复次数</span><br><span class="line">    __block NSUInteger repeatCount = 1;</span><br><span class="line">    //记录当前遍历到的图片之前的图片</span><br><span class="line">    __block UIImage *previousImage = animatedImages.firstObject;</span><br><span class="line">    </span><br><span class="line">    //遍历图片数组</span><br><span class="line">    [animatedImages enumerateObjectsUsingBlock:^(UIImage * _Nonnull image, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        // 第一张图片不处理，忽略掉</span><br><span class="line">        if (idx == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果这一帧的图片和之前一帧图片相同就添加重复次数</span><br><span class="line">        if ([image isEqual:previousImage]) &#123;</span><br><span class="line">            repeatCount++;</span><br><span class="line">        &#125; else &#123;// 如果两帧图片不相同，就生成SDWebImageFrame对象</span><br><span class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:previousImage duration:avgDuration * repeatCount];</span><br><span class="line">            // 数组记录对象</span><br><span class="line">            [frames addObject:frame];</span><br><span class="line">            // 重复次数设置为1次</span><br><span class="line">            repeatCount = 1;</span><br><span class="line">            // 记录不同的帧图片的数量加1</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        //记录当前图片，用于下次遍历使用</span><br><span class="line">        previousImage = image;</span><br><span class="line">        // 最后一张图片</span><br><span class="line">        if (idx == frameCount - 1) &#123;</span><br><span class="line">            // 如果是最后一张照片就直接添加</span><br><span class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:previousImage duration:avgDuration * repeatCount];</span><br><span class="line">            [frames addObject:frame];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">#else //以下非iOS实现，一些东西不同，不做分析</span><br><span class="line">    </span><br><span class="line">    NSBitmapImageRep *bitmapRep;</span><br><span class="line">    for (NSImageRep *imageRep in animatedImage.representations) &#123;</span><br><span class="line">        if ([imageRep isKindOfClass:[NSBitmapImageRep class]]) &#123;</span><br><span class="line">            bitmapRep = (NSBitmapImageRep *)imageRep;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (bitmapRep) &#123;</span><br><span class="line">        frameCount = [[bitmapRep valueForProperty:NSImageFrameCount] unsignedIntegerValue];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (frameCount == 0) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (size_t i = 0; i &lt; frameCount; i++) &#123;</span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            //NSBitmapImageRep需要手动更改帧。 “Good taste”API</span><br><span class="line">            [bitmapRep setProperty:NSImageCurrentFrame withValue:@(i)];</span><br><span class="line">            float frameDuration = [[bitmapRep valueForProperty:NSImageCurrentFrameDuration] floatValue];</span><br><span class="line">            NSImage *frameImage = [[NSImage alloc] initWithCGImage:bitmapRep.CGImage size:CGSizeZero];</span><br><span class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:frameImage duration:frameDuration];</span><br><span class="line">            [frames addObject:frame];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    return frames;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图片方向处理"><a href="#图片方向处理" class="headerlink" title="图片方向处理"></a>图片方向处理</h4><p>将EXIF图片方向转换为iOS图片方向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 将EXIF图片方向转换为iOS图片方向。</span><br><span class="line"></span><br><span class="line"> @param exifOrientation EXIF图片方向</span><br><span class="line"> @return iOS图片方向</span><br><span class="line"> */</span><br><span class="line">+ (UIImageOrientation)imageOrientationFromEXIFOrientation:(NSInteger)exifOrientation;</span><br></pre></td></tr></table></figure><p>方法实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 将EXIF图片方向转换为iOS图片方向。根据EXIF图片方向做判断，返回iOS图片方向</span><br><span class="line">+ (UIImageOrientation)imageOrientationFromEXIFOrientation:(NSInteger)exifOrientation &#123;</span><br><span class="line">    // CGImagePropertyOrientation在上面的iOS 8上可用。 目前保持兼容性</span><br><span class="line">    UIImageOrientation imageOrientation = UIImageOrientationUp;</span><br><span class="line">    switch (exifOrientation) &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            imageOrientation = UIImageOrientationUp;</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            imageOrientation = UIImageOrientationDown;</span><br><span class="line">            break;</span><br><span class="line">        case 8:</span><br><span class="line">            imageOrientation = UIImageOrientationLeft;</span><br><span class="line">            break;</span><br><span class="line">        case 6:</span><br><span class="line">            imageOrientation = UIImageOrientationRight;</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            imageOrientation = UIImageOrientationUpMirrored;</span><br><span class="line">            break;</span><br><span class="line">        case 4:</span><br><span class="line">            imageOrientation = UIImageOrientationDownMirrored;</span><br><span class="line">            break;</span><br><span class="line">        case 5:</span><br><span class="line">            imageOrientation = UIImageOrientationLeftMirrored;</span><br><span class="line">            break;</span><br><span class="line">        case 7:</span><br><span class="line">            imageOrientation = UIImageOrientationRightMirrored;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return imageOrientation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将iOS方向转换为EXIF图片方向</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">将iOS方向转换为EXIF图片方向</span><br><span class="line"></span><br><span class="line"> @param imageOrientation iOS方向</span><br><span class="line"> @return EXIF图片方向</span><br><span class="line"> */</span><br><span class="line">+ (NSInteger)exifOrientationFromImageOrientation:(UIImageOrientation)imageOrientation;</span><br></pre></td></tr></table></figure><p>方法实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 将iOS方向转换为EXIF图片方向，根据iOS方向做判断，返回EXIF图片方向</span><br><span class="line">+ (NSInteger)exifOrientationFromImageOrientation:(UIImageOrientation)imageOrientation &#123;</span><br><span class="line">    // CGImagePropertyOrientation 在上面的iOS 8上可用。 目前保持兼容性</span><br><span class="line">    NSInteger exifOrientation = 1;</span><br><span class="line">    switch (imageOrientation) &#123;</span><br><span class="line">        case UIImageOrientationUp:</span><br><span class="line">            exifOrientation = 1;</span><br><span class="line">            break;</span><br><span class="line">        case UIImageOrientationDown:</span><br><span class="line">            exifOrientation = 3;</span><br><span class="line">            break;</span><br><span class="line">        case UIImageOrientationLeft:</span><br><span class="line">            exifOrientation = 8;</span><br><span class="line">            break;</span><br><span class="line">        case UIImageOrientationRight:</span><br><span class="line">            exifOrientation = 6;</span><br><span class="line">            break;</span><br><span class="line">        case UIImageOrientationUpMirrored:</span><br><span class="line">            exifOrientation = 2;</span><br><span class="line">            break;</span><br><span class="line">        case UIImageOrientationDownMirrored:</span><br><span class="line">            exifOrientation = 4;</span><br><span class="line">            break;</span><br><span class="line">        case UIImageOrientationLeftMirrored:</span><br><span class="line">            exifOrientation = 5;</span><br><span class="line">            break;</span><br><span class="line">        case UIImageOrientationRightMirrored:</span><br><span class="line">            exifOrientation = 7;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return exifOrientation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两个私有方法-计算最大公约数"><a href="#两个私有方法-计算最大公约数" class="headerlink" title="两个私有方法: 计算最大公约数"></a>两个私有方法: 计算最大公约数</h4><p>计算两个整数a和b的最大公约数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static NSUInteger gcd(NSUInteger a, NSUInteger b) &#123;</span><br><span class="line">    NSUInteger c;</span><br><span class="line">    while (a != 0) &#123;</span><br><span class="line">        c = a;</span><br><span class="line">        a = b % a;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算一个整数数组的最大公约数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static NSUInteger gcdArray(size_t const count, NSUInteger const * const values) &#123;</span><br><span class="line">    if (count == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    NSUInteger result = values[0];</span><br><span class="line">    for (size_t i = 1; i &lt; count; ++i) &#123;</span><br><span class="line">        result = gcd(values[i], result);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;SDWebImage&lt;/code&gt; 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（&lt;code&gt;SDWebImageCodersManager&lt;/code&gt;）、编解码协议（&lt;code&gt;SDWebImageCoder&lt;/code&gt;）、PNG/JPEG/TIFF编解码，解压缩，显示大图（&lt;code&gt;SDWebImageImageIOCoder&lt;/code&gt;）、GIF编解码（&lt;code&gt;SDWebImageGIFCoder&lt;/code&gt;）、WebP编解码（&lt;code&gt;SDWebImageWebPCoder&lt;/code&gt;）以及辅助类（&lt;code&gt;SDWebImageCoderHelper&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;本篇只做 &lt;code&gt;SDWebImageCoderHelper&lt;/code&gt; 类的分析。该类作为辅助类，主要实现了两个功能：动图处理 和 图片方向处理。每个功能有两种方法，均为互逆方法。&lt;/p&gt;
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 六 （编码器一：SDWebImageCoder）</title>
    <link href="http://guohuaden.com/2018/10/13/Read-SDWebImage-SDWebImageCoder/"/>
    <id>http://guohuaden.com/2018/10/13/Read-SDWebImage-SDWebImageCoder/</id>
    <published>2018-10-13T13:15:04.000Z</published>
    <updated>2018-10-26T03:07:23.441Z</updated>
    
    <content type="html"><![CDATA[<p><code>SDWebImage</code> 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（<code>SDWebImageCodersManager</code>）、编解码协议（<code>SDWebImageCoder</code>）、PNG/JPEG/TIFF编解码，解压缩，显示大图（<code>SDWebImageImageIOCoder</code>）、GIF编解码（<code>SDWebImageGIFCoder</code>）、WebP编解码（<code>SDWebImageWebPCoder</code>）以及辅助类（<code>SDWebImageCoderHelper</code>）</p><p>本篇只做 <code>SDWebImageCoder</code> 的分析。 <code>SDWebImageCoder</code> 是编解码协议，包含两个协议：<code>SDWebImageCoder</code> 和 <code>SDWebImageProgressiveCoder</code>，两个协议定义了图片编解码类的接口。</p><a id="more"></a><h4 id="公共变量与函数"><a href="#公共变量与函数" class="headerlink" title="公共变量与函数"></a>公共变量与函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> //一个bool类型的key，标记在解压缩期间是否缩小大图片。使用：@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(BOOL值)&#125;</span><br><span class="line">FOUNDATION_EXPORT NSString * _Nonnull const SDWebImageCoderScaleDownLargeImagesKey;</span><br><span class="line"></span><br><span class="line">//.m文件</span><br><span class="line">NSString * const SDWebImageCoderScaleDownLargeImagesKey = @&quot;scaleDownLargeImages&quot;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 返回使用CGColorSpaceCreateDeviceRGB创建的共享设备相关RGB颜色空间。</span><br><span class="line"></span><br><span class="line"> @return 与设备相关RGB颜色空间</span><br><span class="line"> */</span><br><span class="line">CG_EXTERN CGColorSpaceRef _Nonnull SDCGColorSpaceGetDeviceRGB(void);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 检查 CGImageRef 是否包含 alpha 通道</span><br><span class="line"></span><br><span class="line"> @param imageRef The CGImageRef</span><br><span class="line"> @return 如果CGImageRef包含alpha通道，则返回YES，否则返回NO</span><br><span class="line"> */</span><br><span class="line">CG_EXTERN BOOL SDCGImageRefContainsAlpha(_Nullable CGImageRef imageRef);</span><br></pre></td></tr></table></figure><h4 id="两个函数的实现"><a href="#两个函数的实现" class="headerlink" title="两个函数的实现"></a>两个函数的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//定义了一个单利方法，获取设备的RGB色彩空间</span><br><span class="line">CGColorSpaceRef SDCGColorSpaceGetDeviceRGB(void) &#123;</span><br><span class="line">    //通过单例模式获取设备的RGB色彩空间并返回</span><br><span class="line">    static CGColorSpaceRef colorSpace;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        colorSpace = CGColorSpaceCreateDeviceRGB();</span><br><span class="line">    &#125;);</span><br><span class="line">    return colorSpace;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//检查图片是否有透明度</span><br><span class="line">BOOL SDCGImageRefContainsAlpha(CGImageRef imageRef) &#123;</span><br><span class="line">    //如果没有图片就返回没有透明度</span><br><span class="line">    if (!imageRef) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    //获取图片的透明度信息</span><br><span class="line">    CGImageAlphaInfo alphaInfo = CGImageGetAlphaInfo(imageRef);</span><br><span class="line">    //如果满足下面的任何一个选项，就代表没有透明度；否则就有透明度</span><br><span class="line">    BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone ||</span><br><span class="line">                      alphaInfo == kCGImageAlphaNoneSkipFirst ||</span><br><span class="line">                      alphaInfo == kCGImageAlphaNoneSkipLast);</span><br><span class="line">    return hasAlpha;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两个协议"><a href="#两个协议" class="headerlink" title="两个协议"></a>两个协议</h4><h5 id="SDWebImageCoder-协议"><a href="#SDWebImageCoder-协议" class="headerlink" title="SDWebImageCoder 协议"></a><code>SDWebImageCoder</code> 协议</h5><p>该协议提供自定义图像解码/编码的图像编码器协议。<br>需要注意的是：不要从主队列调用这些方法。<br>该协议使用了 <code>@required</code> 关键词，标志着里面的协议方法必须实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@required //标志着里面的协议方法必须实现</span><br><span class="line"></span><br><span class="line">#pragma mark - 解码</span><br><span class="line">/**</span><br><span class="line"> 如果此编码器可以解码某些data，返回YES，否则，它应该传递给另一个编码器</span><br><span class="line"> </span><br><span class="line"> @param data 需要解码的图片数据</span><br><span class="line"> @return 如果此编码器可以解码图片，返回YES，否则返回NO</span><br><span class="line"> */</span><br><span class="line">- (BOOL)canDecodeFromData:(nullable NSData *)data;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 将图片数据解码为图片。</span><br><span class="line"> </span><br><span class="line"> @param data 需要解码的图片数据</span><br><span class="line"> @return 解码后得到的图片</span><br><span class="line"> */</span><br><span class="line">- (nullable UIImage *)decodedImageWithData:(nullable NSData *)data;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">使用原始图片和图片数据解压缩图片。</span><br><span class="line"></span><br><span class="line"> @param image 需要压缩的原图片</span><br><span class="line"> @param data 指向原始图像数据的指针。 指针本身是非空的，但图像数据可以为空。 如果需要，此数据将设置为缓存。 如果您不需要同时修改数据，请忽略此参数。</span><br><span class="line"> @param optionsDict 一个包含任何解压缩选项的字典。 通过&#123;SDWebImageCoderScaleDownLargeImagesKey：@（YES）&#125;缩小大图像</span><br><span class="line"> @return 解压缩后的图片</span><br><span class="line"> */</span><br><span class="line">- (nullable UIImage *)decompressedImageWithImage:(nullable UIImage *)image</span><br><span class="line">                                            data:(NSData * _Nullable * _Nonnull)data</span><br><span class="line">                                         options:(nullable NSDictionary&lt;NSString*, NSObject*&gt;*)optionsDict;</span><br><span class="line"></span><br><span class="line">#pragma mark -编码</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 如果此编码器可以编码某些图片，返回YES，否则，它应该传递给另一个编码器</span><br><span class="line"> </span><br><span class="line"> @param format 图片格式</span><br><span class="line"> @return 如果此编码器可以编码图片，返回YES，否则返回NO</span><br><span class="line"> */</span><br><span class="line">- (BOOL)canEncodeToFormat:(SDImageFormat)format;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 将图片编码为图片数据（imagedata）</span><br><span class="line"></span><br><span class="line"> @param image 需要编码的图片</span><br><span class="line"> @param format 要编码的图片格式, 也有可能是 `SDImageFormatUndefined` 格式（未识别格式）</span><br><span class="line"> @return The encoded image data</span><br><span class="line"> */</span><br><span class="line">- (nullable NSData *)encodedDataWithImage:(nullable UIImage *)image format:(SDImageFormat)format;</span><br></pre></td></tr></table></figure><h5 id="SDWebImageProgressiveCoder-协议"><a href="#SDWebImageProgressiveCoder-协议" class="headerlink" title="SDWebImageProgressiveCoder 协议"></a><code>SDWebImageProgressiveCoder</code> 协议</h5><p>该协议提供自定义逐行图像解码的图像编码器协议。<br>注意：不要从主队列调用这些方法。<br>该协议使用了 <code>@required</code> 关键词，标志着里面的协议方法必须实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">`@required` //标志着里面的协议方法必须实现</span><br><span class="line">/**</span><br><span class="line"> 如果此编码器可以增量解码某些数据，返回YES，否则，它应该传递给另一个解码器。</span><br><span class="line"> </span><br><span class="line"> @param data 图片数据，以便可以查看它</span><br><span class="line"> @return 如果此编码器可以增量解码该数据，返回YES，否则返回NO</span><br><span class="line"> */</span><br><span class="line">- (BOOL)canIncrementallyDecodeFromData:(nullable NSData *)data;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">将图片数据增量解码为图片</span><br><span class="line"></span><br><span class="line"> @param data 到目前为止已下载的图片数据</span><br><span class="line"> @param finished 下载是否已经结束</span><br><span class="line"> @warning 因为增量解码需要保持解码的上下文，我们将为每个下载操作分配一个具有相同类的新实例，以避免冲突</span><br><span class="line"> @return The decoded image from data</span><br><span class="line"> */</span><br><span class="line">- (nullable UIImage *)incrementallyDecodedImageWithData:(nullable NSData *)data finished:(BOOL)finished;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;SDWebImage&lt;/code&gt; 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（&lt;code&gt;SDWebImageCodersManager&lt;/code&gt;）、编解码协议（&lt;code&gt;SDWebImageCoder&lt;/code&gt;）、PNG/JPEG/TIFF编解码，解压缩，显示大图（&lt;code&gt;SDWebImageImageIOCoder&lt;/code&gt;）、GIF编解码（&lt;code&gt;SDWebImageGIFCoder&lt;/code&gt;）、WebP编解码（&lt;code&gt;SDWebImageWebPCoder&lt;/code&gt;）以及辅助类（&lt;code&gt;SDWebImageCoderHelper&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;本篇只做 &lt;code&gt;SDWebImageCoder&lt;/code&gt; 的分析。 &lt;code&gt;SDWebImageCoder&lt;/code&gt; 是编解码协议，包含两个协议：&lt;code&gt;SDWebImageCoder&lt;/code&gt; 和 &lt;code&gt;SDWebImageProgressiveCoder&lt;/code&gt;，两个协议定义了图片编解码类的接口。&lt;/p&gt;
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
</feed>
