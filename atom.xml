<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>喂：一二三</title>
  
  <subtitle>低调、踏实、前行。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://guohuaden.com/"/>
  <updated>2019-04-14T07:39:03.690Z</updated>
  <id>http://guohuaden.com/</id>
  
  <author>
    <name>Wheat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>每周算法--篇四</title>
    <link href="http://guohuaden.com/2019/04/14/Arithmetic-weekly4/"/>
    <id>http://guohuaden.com/2019/04/14/Arithmetic-weekly4/</id>
    <published>2019-04-14T03:46:09.000Z</published>
    <updated>2019-04-14T07:39:03.690Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题：实现一个函数，把字符串中的每个空格替换成”-20”。例如：”We-are-family-”-则输出-“We-20are-20family-”。"><a href="#题：实现一个函数，把字符串中的每个空格替换成”-20”。例如：”We-are-family-”-则输出-“We-20are-20family-”。" class="headerlink" title="题：实现一个函数，把字符串中的每个空格替换成”%20”。例如：”We are family.”,则输出 “We%20are%20family.”。"></a>题：实现一个函数，把字符串中的每个空格替换成”%20”。例如：”We are family.”,则输出 “We%20are%20family.”。</h4><h4 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h4><p>在网络编程中，如果URL参数中含有特殊字符，如空格、’#’等，则可能导致服务器端无法获得正确的参数值。我们需要将这些特殊符号转成服务器可以识别的字符。<strong>转换的规则是在’%’后面跟上ASCII码的两位十六进制的表示</strong>。比如空格的ASCII码是32，即十六进制的0x20，因此空格被替换成’%20’；再比如’#’的ASCII码为35，即十六进制的0x23,它在URL中被替换为’%23’。</p><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>这题的规则很简单，将空格替换成’%20’，那么需要考虑的就是时间复杂度的问题。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><p>最简单的想法是：直接遍历字符串中的字符，遇到空格便将其替换成’%20’，但有一些问题，空格的长度和’%20’的长度是不等的，那么结果是需要将每个空格后面的字符向后移动。举个例子：如果字符串的长度为n，对每个空格字符，需要移动后面的O(n)个字符，因此对于含有O(n)个空格字符的字符串而言，总的时间复杂度为：O(n^2)。</p><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><p>使用辅助空间，遍历字符串的每个字符，将其添加到辅助字符串中，添加的过程中将空格替换成’%20’。这种方法是牺牲空复杂度间换取时间复杂度。时间复杂度为：O(n)。</p><h5 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h5><p>先遍历一遍字符串，找出其中的空格，确定替换后的字符转的长度。然后从字符串的后面开始复制和替换。首先准备两个指针：P1和P2。P1指向原始字符串的末尾，P2则指向替换之后的字符串的末尾。<strong>实现步骤：</strong>做好之前的准备后，向前移动指针P1，诸葛把它指向的字符复制到P2指向的位置，直到碰到第一个空格为止。时间复杂度为：O(n)。</p><h4 id="代码实践："><a href="#代码实践：" class="headerlink" title="代码实践："></a>代码实践：</h4><p><strong>方法一实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">1000</span>] = <span class="string">"We are family."</span>;</span><br><span class="line"><span class="keyword">int</span> stringlen = <span class="built_in">strlen</span>(<span class="built_in">string</span>);</span><br><span class="line"><span class="keyword">int</span> indexNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringlen; i++)&#123;</span><br><span class="line"><span class="keyword">char</span> charStr = <span class="built_in">string</span>[i];</span><br><span class="line"><span class="keyword">if</span> (charStr == <span class="string">' '</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//将空格之后的字符向后移动</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = stringlen;j &gt; i; j--) &#123;</span><br><span class="line"><span class="built_in">string</span>[j+<span class="number">2</span>] = <span class="built_in">string</span>[j]; </span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span>[++indexNum] = <span class="string">'%'</span>;</span><br><span class="line"><span class="built_in">string</span>[++indexNum] = <span class="string">'2'</span>;</span><br><span class="line"><span class="built_in">string</span>[++indexNum] = <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">i = i+<span class="number">2</span>;  </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">indexNum = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n-----one3 %s\n"</span>,<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure><p><strong>方法二实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">"We are family."</span>;</span><br><span class="line"><span class="keyword">int</span> strLen = <span class="built_in">strlen</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这段代码是用来计算辅助字符串的长度的;</span></span><br><span class="line"><span class="keyword">char</span> replaceStr[] = <span class="string">"%20"</span>;</span><br><span class="line"><span class="comment">//统计空格的数目</span></span><br><span class="line"><span class="keyword">int</span> bankNumber = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strLen; i++)&#123;</span><br><span class="line"><span class="keyword">char</span> charStr = str[i];</span><br><span class="line"><span class="keyword">if</span> (charStr == <span class="string">' '</span>) &#123;</span><br><span class="line">bankNumber++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> replacelen = bankNumber * (<span class="built_in">strlen</span>(replaceStr)<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> repStrNewlen = strLen + replacelen; </span><br><span class="line"></span><br><span class="line"><span class="comment">//根据计算的字符串长度，创建辅助字符串</span></span><br><span class="line"><span class="keyword">char</span> newStr[repStrNewlen] ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将str中的字符复制到辅助字符串中，并将空格替换为'%20'</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (strLen &gt; <span class="number">0</span> &amp;&amp; num &lt;= strLen) &#123;</span><br><span class="line"><span class="keyword">char</span> charS = str[num];</span><br><span class="line"><span class="keyword">if</span> (charS == <span class="string">' '</span>) &#123;</span><br><span class="line">newStr[index++] = <span class="string">'%'</span>;</span><br><span class="line">newStr[index++] = <span class="string">'2'</span>;</span><br><span class="line">newStr[index++] = <span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">newStr[index++] = charS;</span><br><span class="line">&#125;</span><br><span class="line">++num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"--------one2Result == %s"</span>,newStr);</span><br></pre></td></tr></table></figure><p><strong>方法三实现：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[] = <span class="string">"We are family."</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计空格的数目</span></span><br><span class="line"><span class="keyword">int</span> bankNumber = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> replaceStr[] = <span class="string">"%20"</span>;</span><br><span class="line"><span class="keyword">int</span> stringlen = <span class="built_in">strlen</span>(<span class="built_in">string</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringlen; i++)&#123;</span><br><span class="line"><span class="keyword">char</span> charStr = <span class="built_in">string</span>[i];</span><br><span class="line"><span class="keyword">if</span> (charStr == <span class="string">' '</span>) &#123;</span><br><span class="line">bankNumber++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//替换字符增加的长度</span></span><br><span class="line"><span class="keyword">int</span> replacelen = bankNumber * (<span class="built_in">strlen</span>(replaceStr)<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//替换后的字符串长度</span></span><br><span class="line"><span class="keyword">int</span> repStrNewlen = stringlen + replacelen; </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (stringlen &gt;= <span class="number">0</span> &amp;&amp; stringlen &lt; repStrNewlen) &#123;  </span><br><span class="line"><span class="keyword">char</span> char1 = <span class="built_in">string</span>[stringlen];</span><br><span class="line"><span class="keyword">if</span> (char1 == <span class="string">' '</span>) &#123;</span><br><span class="line"><span class="built_in">string</span>[repStrNewlen--] = <span class="string">'0'</span>;</span><br><span class="line"><span class="built_in">string</span>[repStrNewlen--] = <span class="string">'2'</span>;</span><br><span class="line"><span class="built_in">string</span>[repStrNewlen--] = <span class="string">'%'</span>;</span><br><span class="line">bankNumber--;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">string</span>[repStrNewlen--] = char1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--stringlen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"result==%s \n"</span>,<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题：实现一个函数，把字符串中的每个空格替换成”-20”。例如：”We-are-family-”-则输出-“We-20are-20family-”。&quot;&gt;&lt;a href=&quot;#题：实现一个函数，把字符串中的每个空格替换成”-20”。例如：”We-are-family-”
      
    
    </summary>
    
      <category term="每周算法" scheme="http://guohuaden.com/categories/%E6%AF%8F%E5%91%A8%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="每周算法,算法" scheme="http://guohuaden.com/tags/%E6%AF%8F%E5%91%A8%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>每周算法--篇三</title>
    <link href="http://guohuaden.com/2019/04/12/Arithmetic-weekly3/"/>
    <id>http://guohuaden.com/2019/04/12/Arithmetic-weekly3/</id>
    <published>2019-04-12T08:00:18.000Z</published>
    <updated>2019-04-14T07:34:29.431Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题：在一个二维数组中，每一行都按照从左到右递增的顺序排列，每一列都按照从上到下递增的顺序排列。判断数组中是否含有某个整数。"><a href="#题：在一个二维数组中，每一行都按照从左到右递增的顺序排列，每一列都按照从上到下递增的顺序排列。判断数组中是否含有某个整数。" class="headerlink" title="题：在一个二维数组中，每一行都按照从左到右递增的顺序排列，每一列都按照从上到下递增的顺序排列。判断数组中是否含有某个整数。"></a>题：在一个二维数组中，每一行都按照从左到右递增的顺序排列，每一列都按照从上到下递增的顺序排列。判断数组中是否含有某个整数。</h3><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>二维数组。而且数组的排列顺序也给了规定：每一行都按照从左到右递增的顺序排列，每一列都按照从上到下递增的顺序排列。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>二分查找方法，以及利用二维数组的排列顺序规则进行查找。</p><h4 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h4><h5 id="1、将二维数组转换成一维有序数组，然后通过二分法查找该有序数组找到目标数。"><a href="#1、将二维数组转换成一维有序数组，然后通过二分法查找该有序数组找到目标数。" class="headerlink" title="1、将二维数组转换成一维有序数组，然后通过二分法查找该有序数组找到目标数。"></a>1、将二维数组转换成一维有序数组，然后通过二分法查找该有序数组找到目标数。</h5><h5 id="2、首先选取数组中右上角的数字。如果该数字等于要查找的数字，则查找过程结束；如果该数字大于要查找的数字，则剔除这个数字所在的列；如果该数字小于要查找的数字，则剔除这个数字所在的行。也就是说，如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。"><a href="#2、首先选取数组中右上角的数字。如果该数字等于要查找的数字，则查找过程结束；如果该数字大于要查找的数字，则剔除这个数字所在的列；如果该数字小于要查找的数字，则剔除这个数字所在的行。也就是说，如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。" class="headerlink" title="2、首先选取数组中右上角的数字。如果该数字等于要查找的数字，则查找过程结束；如果该数字大于要查找的数字，则剔除这个数字所在的列；如果该数字小于要查找的数字，则剔除这个数字所在的行。也就是说，如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。"></a>2、首先选取数组中右上角的数字。如果该数字等于要查找的数字，则查找过程结束；如果该数字大于要查找的数字，则剔除这个数字所在的列；如果该数字小于要查找的数字，则剔除这个数字所在的行。也就是说，如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">10</span>&#125;, &#123;<span class="number">10</span>,<span class="number">12</span>,<span class="number">23</span>&#125;, &#123;<span class="number">21</span>,<span class="number">23</span>,<span class="number">36</span>&#125;, &#123;<span class="number">33</span>,<span class="number">36</span>,<span class="number">37</span>&#125;, &#123;<span class="number">42</span>,<span class="number">46</span>,<span class="number">49</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>,  <span class="number">7</span> , <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>, <span class="number">12</span>, <span class="number">23</span></span><br><span class="line"></span><br><span class="line"><span class="number">21</span>, <span class="number">23</span>, <span class="number">36</span></span><br><span class="line"></span><br><span class="line"><span class="number">33</span>, <span class="number">36</span>, <span class="number">37</span></span><br><span class="line"></span><br><span class="line"><span class="number">42</span>, <span class="number">46</span>, <span class="number">49</span></span><br></pre></td></tr></table></figure><h4 id="代码实践："><a href="#代码实践：" class="headerlink" title="代码实践："></a>代码实践：</h4><p><strong>方案一：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>][<span class="number">3</span>]=&#123; &#123;<span class="number">5</span>,<span class="number">7</span>,<span class="number">10</span>&#125;, &#123;<span class="number">10</span>,<span class="number">12</span>,<span class="number">23</span>&#125;, &#123;<span class="number">21</span>,<span class="number">23</span>,<span class="number">36</span>&#125;, &#123;<span class="number">33</span>,<span class="number">36</span>,<span class="number">37</span>&#125;, &#123;<span class="number">42</span>,<span class="number">46</span>,<span class="number">49</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> targetNumber =  <span class="number">33</span>;</span><br><span class="line"><span class="keyword">int</span> numbers = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//行数 </span></span><br><span class="line"><span class="keyword">int</span> rowNumbers = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);  <span class="comment">// 5</span></span><br><span class="line"><span class="comment">//列数</span></span><br><span class="line"><span class="keyword">int</span> lineNumbers= <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//转成一维数组</span></span><br><span class="line"><span class="keyword">int</span> arrB[numbers];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rowNumbers;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; lineNumbers;j++)&#123;</span><br><span class="line">arrB[i*lineNumbers+j] = arr[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;numbers ; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arrB[j] &gt; arrB[j - <span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">int</span> temp = arrB[j];</span><br><span class="line">arrB[j] = arrB[j - <span class="number">1</span>];</span><br><span class="line">arrB[j - <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = numbers;</span><br><span class="line"><span class="keyword">int</span> middle = (start+end)*<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(middle &gt;= start || middle &lt;= end)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = arrB[middle];</span><br><span class="line"><span class="keyword">if</span> (num == targetNumber) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-----%d-----"</span>,num);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &gt; targetNumber)&#123;</span><br><span class="line">middle =  (end-middle)/<span class="number">2</span> + middle;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &lt; targetNumber)&#123;</span><br><span class="line">middle =  (middle-start)/<span class="number">2</span> + start;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方案二：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">示例二维数组： int example[5][10]</span><br><span class="line">数组的总数为： </span><br><span class="line">sizeof(example) / sizeof(int)// sizeof(example)为该数组的大小(这里是5x10)，sizeof(int)为int类型的大小(4)</span><br><span class="line">数组列数为： </span><br><span class="line">sizeof(example[0])/sizeof(int)// sizeof(example[0])为该数组一行的大小(这里是10)</span><br><span class="line">数组行数则为 ：</span><br><span class="line">( sizeof(example) / sizeof(int) )/ ( sizeof(example[0]) / sizeof(int) )</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int arr[5][3]=&#123; &#123;5,7,10&#125;, &#123;10,12,23&#125;, &#123;21,23,36&#125;, &#123;33,36,37&#125;, &#123;42,46,49&#125; &#125;;</span><br><span class="line"></span><br><span class="line">int targetNumber =  33;</span><br><span class="line">int numbers = sizeof(arr) / sizeof(int);</span><br><span class="line"></span><br><span class="line">//行数 </span><br><span class="line">int rowNumbers = sizeof(arr)/sizeof(arr[0]);  // 5</span><br><span class="line">//列数</span><br><span class="line">int lineNumbers= sizeof(arr[0])/sizeof(int);  // 3</span><br><span class="line"></span><br><span class="line">int rowIndex = 0;</span><br><span class="line">bool result = false;</span><br><span class="line">while(lineNumbers &gt;= 0 &amp;&amp; rowNumbers &gt;= 0)&#123;</span><br><span class="line"></span><br><span class="line">int number = arr[rowIndex][lineNumbers-1];</span><br><span class="line">if (number == targetNumber) &#123;</span><br><span class="line">result = true;</span><br><span class="line">printf(&quot;-------%d----&quot;,number);</span><br><span class="line">return;</span><br><span class="line">&#125;else if(number &gt; targetNumber &amp;&amp; lineNumbers &gt;0)&#123;</span><br><span class="line">lineNumbers--;</span><br><span class="line">&#125;else if(number &lt; targetNumber &amp;&amp; rowIndex &lt; rowNumbers)&#123;</span><br><span class="line">rowIndex++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (result == false) &#123;</span><br><span class="line">printf(&quot;数组中未找到该数字&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题：在一个二维数组中，每一行都按照从左到右递增的顺序排列，每一列都按照从上到下递增的顺序排列。判断数组中是否含有某个整数。&quot;&gt;&lt;a href=&quot;#题：在一个二维数组中，每一行都按照从左到右递增的顺序排列，每一列都按照从上到下递增的顺序排列。判断数组中是否含有某个整
      
    
    </summary>
    
      <category term="每周算法" scheme="http://guohuaden.com/categories/%E6%AF%8F%E5%91%A8%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="每周算法、算法" scheme="http://guohuaden.com/tags/%E6%AF%8F%E5%91%A8%E7%AE%97%E6%B3%95%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>每周算法--篇二</title>
    <link href="http://guohuaden.com/2019/04/11/Arithmetic-weekly2/"/>
    <id>http://guohuaden.com/2019/04/11/Arithmetic-weekly2/</id>
    <published>2019-04-11T03:58:52.000Z</published>
    <updated>2019-04-10T11:50:54.829Z</updated>
    
    <content type="html"><![CDATA[<h3 id="找出数组中重复的数字"><a href="#找出数组中重复的数字" class="headerlink" title="找出数组中重复的数字"></a>找出数组中重复的数字</h3><h4 id="描述："><a href="#描述：" class="headerlink" title="描述："></a>描述：</h4><p>在一个长度为n的数组里的所有数字都在0~n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如：如果输入长度为 7 的数组{2，3，1，0，2，5，3}，那么对应的输出是重复的数字2或者3。</p><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>从数组中找出重复的数字，如果没有提示！</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>遍历数组进行匹配，考虑时间复杂度问题。</p><h4 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h4><h5 id="1、双重遍历"><a href="#1、双重遍历" class="headerlink" title="1、双重遍历"></a>1、双重遍历</h5><p>将数组中的每一个数与其他数做匹配，如果两者相等，输出，否则输出未找到提示。</p><h5 id="2、排序-遍历"><a href="#2、排序-遍历" class="headerlink" title="2、排序+遍历"></a>2、排序+遍历</h5><p>将数组排序，匹配相邻者数字，如果两者相等，输出，否则输出未找到提示。</p><h5 id="3、哈希表-遍历"><a href="#3、哈希表-遍历" class="headerlink" title="3、哈希表+遍历"></a>3、哈希表+遍历</h5><p>将遍历时的每个数存入哈希表中，每次存入的时候判断下是否</p><h5 id="4、辅助数组-遍历"><a href="#4、辅助数组-遍历" class="headerlink" title="4、辅助数组+遍历"></a>4、辅助数组+遍历</h5><p>创建一个辅助数组，然后逐一把原数组的每个数字复制到辅助数组中，如果原数组中被复制的数字是n,则把它复制到辅助数组中下标为n的位置。如果该位置已有相同的数字，则该数字为重复数字。该方案需要O(n)的辅助空间。</p><h5 id="5、类似二分查找方法"><a href="#5、类似二分查找方法" class="headerlink" title="5、类似二分查找方法"></a>5、类似二分查找方法</h5><p>前提：在一个长度为n的数组里的所有数字都在0~n-1的范围内。我们把从0~n-1的数字从中间的数字【 (n-1)/2】（下面以m表示）分为两部分，前半部分为0~m,后半部分为m+1 ~ n-1。如果1~m的数字个数超过m，则这个区间一定存在重复的数字；否则后半部分区间一定存在重复的数字。继续重复分割数字区间，直到找到一个重复的数字。</p><h4 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践:"></a>代码实践:</h4><p><strong>双重遍历</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> number = arr[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i;j&lt;len;j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (number == arr[j]) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,number);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"未找到"</span>);</span><br></pre></td></tr></table></figure><p><strong>排序+遍历</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="keyword">int</span> i,j,temp;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">temp = arr[i];</span><br><span class="line"><span class="keyword">for</span> (j=i;j&gt;<span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>]&gt;temp;j--)&#123;</span><br><span class="line">arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> number = arr[index];</span><br><span class="line"><span class="keyword">int</span> next = arr[index+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (number == next) &#123;</span><br><span class="line">result = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"--%d---"</span>,number);</span><br><span class="line">&#125;</span><br><span class="line">index = index+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result == <span class="literal">false</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"未找到"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>哈希表+遍历</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(len &lt;= <span class="number">0</span> )&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =  <span class="number">0</span>; i &lt; len ; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt; <span class="number">0</span> || arr[i] &gt; len<span class="number">-1</span> ) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> number = arr[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(number != i)&#123;</span><br><span class="line"><span class="keyword">int</span> nextNum = arr[number];</span><br><span class="line"><span class="keyword">if</span>(number == nextNum)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,number);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp = number;</span><br><span class="line">arr[i] = nextNum;</span><br><span class="line">arr[number] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、辅助数组+遍历</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr1[len+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> number = arr[i];</span><br><span class="line"><span class="keyword">int</span> tagerNumber = arr1[number];</span><br><span class="line"><span class="keyword">if</span>(number == tagerNumber)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"----%d\n"</span>,number);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">arr1[number] = number;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5、类似二分查找方法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line"><span class="keyword">int</span> middle = (end+start)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//计算区间里的数字数目</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&lt;=middle &amp;&amp; arr[i]&gt;=start)&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果区间内的数字个数大于区间的应有个数（比如：10-20， 中间数为15，区间为10-15，区间内应有5个数）</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; middle-start+<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//说明重复数字在[start,middle]中</span></span><br><span class="line">end = middle;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//说明重复数字在[middle,end]中</span></span><br><span class="line">start = middle+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找索引相遇代表查找结束。</span></span><br><span class="line"><span class="keyword">if</span>(end == start)&#123;</span><br><span class="line"><span class="comment">//count大于0，说明找到重复数字</span></span><br><span class="line"><span class="keyword">if</span>(count &gt; <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,start);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;找出数组中重复的数字&quot;&gt;&lt;a href=&quot;#找出数组中重复的数字&quot; class=&quot;headerlink&quot; title=&quot;找出数组中重复的数字&quot;&gt;&lt;/a&gt;找出数组中重复的数字&lt;/h3&gt;&lt;h4 id=&quot;描述：&quot;&gt;&lt;a href=&quot;#描述：&quot; class=&quot;header
      
    
    </summary>
    
      <category term="每周算法" scheme="http://guohuaden.com/categories/%E6%AF%8F%E5%91%A8%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="每周算法、算法" scheme="http://guohuaden.com/tags/%E6%AF%8F%E5%91%A8%E7%AE%97%E6%B3%95%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>每周算法--篇一</title>
    <link href="http://guohuaden.com/2019/04/04/Arithmetic-weekly1/"/>
    <id>http://guohuaden.com/2019/04/04/Arithmetic-weekly1/</id>
    <published>2019-04-04T02:27:55.000Z</published>
    <updated>2019-04-14T07:37:19.768Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题：找出有序数组中和等于指定数的两个数"><a href="#题：找出有序数组中和等于指定数的两个数" class="headerlink" title="题：找出有序数组中和等于指定数的两个数"></a>题：找出有序数组中和等于指定数的两个数</h3><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>数组是有序的；数组中可能存在两个数相加的和等于给定的值，找出这两个数，如果没有提示。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>首先想到的必须遍历数组，这点是毋庸置疑的。这时需要考虑的就是怎样遍历数组以及时间复杂度问题。</p><h4 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h4><h5 id="1、双重遍历"><a href="#1、双重遍历" class="headerlink" title="1、双重遍历"></a>1、双重遍历</h5><p>最简单也是最笨重的想法是双重遍历：将每个数与另外的数相加，判断是否等于目标值，时间复杂度为O(n*n)。</p><h5 id="2、快速查找法"><a href="#2、快速查找法" class="headerlink" title="2、快速查找法"></a>2、快速查找法</h5><p><strong>方法一：</strong>从两端开始，分别向中间取值匹配。时间复杂度为O(n)。</p><p>(1)如果两数之和&gt;目标值,说明较大加数需要小些，向数组的较小值方向移位取值继续和原较小值重新匹配。</p><p>(2)如果两数之和&lt;目标值,说明较小加数需要大些，向数组的较大值方向移位取值继续和原较大值重新匹配。</p><p><strong>方法二：</strong>近一步思考：以数组中间下标(index)为分界点，分别向左右两边取值匹配。时间复杂度为O(n)。</p><p>  （1）若两数之和&gt;目标值，说明较小加数还要再小，向数组的较小值方向移位取值与原较大值重新匹配。</p><p>  （2）若两数之和&lt;目标值，说明较大加数还要再大，向数组的较大值方向移位取值与原较小值重新匹配。</p><p><strong>方法三：</strong>换一种方式思考，    两个加数一定满足条件：较小加数小于等于目标值的一半，并且较大值大于等于目标值的一半（较小加数&lt;= (目标值/2) &lt;= 较大加数）；那么只需要找出该数组的较小加数和较大加数分界index，以该分界为起点分别往左右两边逐个取值匹配。比较的方式遵循方法二的(1)(2)。时间复杂度仍为O(n)。</p><h4 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h4><h5 id="双重遍历"><a href="#双重遍历" class="headerlink" title="双重遍历"></a>双重遍历</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">NSInteger targetNumber = 90;</span><br><span class="line">NSArray *arr = @[@&quot;4&quot;,@&quot;8&quot;,@&quot;10&quot;,@&quot;15&quot;,@&quot;20&quot;,@&quot;30&quot;,@&quot;35&quot;,@&quot;49&quot;,@&quot;51&quot;,@&quot;60&quot;,@&quot;60&quot;,@&quot;63&quot;,@&quot;70&quot;,@&quot;89&quot;];</span><br><span class="line">BOOL result = NO;</span><br><span class="line"></span><br><span class="line">for(NSInteger i = 0    ; i&lt; arr.count; i++)&#123;</span><br><span class="line">    NSInteger minNumber = [arr[i] integerValue];</span><br><span class="line">    </span><br><span class="line">    for (NSInteger j = i+1;j&lt; arr.count;j++) &#123;</span><br><span class="line">        NSInteger maxNumber = [arr[j] integerValue];</span><br><span class="line">        if(minNumber + maxNumber == targetNumber )&#123;</span><br><span class="line">            NSLog(@&quot;search3 :::::::%li---%li&quot;,minNumber,maxNumber);</span><br><span class="line">            result = YES;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(result == NO)&#123;</span><br><span class="line">    NSLog(@&quot;未找到&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="快速查找"><a href="#快速查找" class="headerlink" title="快速查找"></a>快速查找</h5><p><strong>方法一：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NSInteger targetNumber = 90;</span><br><span class="line">NSArray *arr = @[@&quot;4&quot;,@&quot;8&quot;,@&quot;10&quot;,@&quot;15&quot;,@&quot;20&quot;,@&quot;24&quot;,@&quot;30&quot;,@&quot;35&quot;,@&quot;49&quot;,@&quot;50&quot;,@&quot;60&quot;,@&quot;63&quot;,@&quot;70&quot;,@&quot;89&quot;];</span><br><span class="line">BOOL result = NO;</span><br><span class="line">NSInteger minIndex = 0 ;</span><br><span class="line">NSInteger maxIndex = arr.count-1;</span><br><span class="line">do &#123;</span><br><span class="line">    NSInteger sumNumber = [arr[minIndex] integerValue]+ [arr[maxIndex] integerValue];</span><br><span class="line">    if(sumNumber &gt; targetNumber)&#123;</span><br><span class="line">        maxIndex -- ;</span><br><span class="line">    &#125;else if(sumNumber &lt; targetNumber)&#123;</span><br><span class="line">        minIndex++;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;%@---%@&quot;,arr[minIndex],arr[maxIndex]);</span><br><span class="line">        minIndex++;</span><br><span class="line">        maxIndex--;</span><br><span class="line">        result = YES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125; while (minIndex &lt;= maxIndex);</span><br><span class="line"></span><br><span class="line">if(result == NO)&#123;</span><br><span class="line">    NSLog(@&quot;未找到&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">NSInteger targetNumber = 90;</span><br><span class="line">NSArray *arr = @[@&quot;4&quot;,@&quot;8&quot;,@&quot;10&quot;,@&quot;15&quot;,@&quot;20&quot;,@&quot;24&quot;,@&quot;30&quot;,@&quot;35&quot;,@&quot;49&quot;,@&quot;50&quot;,@&quot;60&quot;,@&quot;63&quot;,@&quot;70&quot;,@&quot;89&quot;];</span><br><span class="line">NSInteger midIndex = arr.count*0.5;</span><br><span class="line">BOOL result = NO;</span><br><span class="line">if(midIndex &gt; 0)&#123;</span><br><span class="line">    NSInteger minIndex = midIndex ;</span><br><span class="line">    NSInteger maxIndex = midIndex+1;</span><br><span class="line">    do &#123;</span><br><span class="line">        NSInteger sumNumber = [arr[minIndex] integerValue]+ [arr[maxIndex] integerValue];</span><br><span class="line">        if(sumNumber &gt; targetNumber)&#123;</span><br><span class="line">            minIndex -- ;</span><br><span class="line">        &#125;else if(sumNumber &lt; targetNumber)&#123;</span><br><span class="line">            maxIndex++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            NSLog(@&quot;%@---%@&quot;,arr[minIndex],arr[maxIndex]);</span><br><span class="line">            minIndex--;</span><br><span class="line">            maxIndex++;</span><br><span class="line">            result = YES;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; while (minIndex &gt;= 0 &amp;&amp; maxIndex &lt; arr.count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(result == NO)&#123;</span><br><span class="line">    NSLog(@&quot;未找到&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法三：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">NSInteger targetNumber = 90;</span><br><span class="line">NSArray *arr = @[@&quot;4&quot;,@&quot;8&quot;,@&quot;10&quot;,@&quot;15&quot;,@&quot;20&quot;,@&quot;30&quot;,@&quot;35&quot;,@&quot;49&quot;,@&quot;51&quot;,@&quot;60&quot;,@&quot;60&quot;,@&quot;63&quot;,@&quot;70&quot;,@&quot;89&quot;];</span><br><span class="line">NSInteger midIndex = 0;</span><br><span class="line">BOOL result = NO;</span><br><span class="line">for (NSInteger i = 0;i&lt;arr.count;i++) &#123;</span><br><span class="line">    if([arr[i] integerValue] &gt; targetNumber*0.5)&#123;</span><br><span class="line">        midIndex = i - 1;</span><br><span class="line">        NSLog(@&quot;%ld&quot;,midIndex);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(midIndex != -1)&#123;</span><br><span class="line">    NSInteger minIndex = midIndex;</span><br><span class="line">    NSInteger maxIndex =  midIndex + 1;</span><br><span class="line">    do &#123;   </span><br><span class="line">        NSInteger sumNumber = [arr[minIndex] integerValue]+ [arr[maxIndex] integerValue];</span><br><span class="line">        if (sumNumber &gt; targetNumber) &#123;</span><br><span class="line">            minIndex--;</span><br><span class="line">        &#125;else if(sumNumber &lt; targetNumber)&#123;</span><br><span class="line">            maxIndex++;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            NSLog(@&quot;%@---%@&quot;,arr[minIndex],arr[maxIndex]);</span><br><span class="line">            minIndex--;</span><br><span class="line">            maxIndex++;</span><br><span class="line">            result = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (minIndex &gt;= 0 &amp;&amp; (maxIndex &lt;= arr.count-1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(result == NO)&#123;</span><br><span class="line">    NSLog(@&quot;未找到&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题：找出有序数组中和等于指定数的两个数&quot;&gt;&lt;a href=&quot;#题：找出有序数组中和等于指定数的两个数&quot; class=&quot;headerlink&quot; title=&quot;题：找出有序数组中和等于指定数的两个数&quot;&gt;&lt;/a&gt;题：找出有序数组中和等于指定数的两个数&lt;/h3&gt;&lt;h4 i
      
    
    </summary>
    
      <category term="每周算法" scheme="http://guohuaden.com/categories/%E6%AF%8F%E5%91%A8%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="每周算法,算法" scheme="http://guohuaden.com/tags/%E6%AF%8F%E5%91%A8%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>隐私协议</title>
    <link href="http://guohuaden.com/2019/01/25/PrivacyPolicy/"/>
    <id>http://guohuaden.com/2019/01/25/PrivacyPolicy/</id>
    <published>2019-01-25T07:19:56.755Z</published>
    <updated>2019-03-02T11:46:53.652Z</updated>
    
    <content type="html"><![CDATA[<p>本软件尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本软件会按照本隐私权政策的规定使用和披露您的个人信息。但本软件将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本软件不会将这些信息对外披露或向第三方提供。本软件会不时更新本隐私权政策。您在同意本软件服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于本软件服务使用协议不可分割的一部分。</p><h3 id="1-适用范围"><a href="#1-适用范围" class="headerlink" title="1.适用范围"></a>1.适用范围</h3><p>a.在您使用本软件网络服务，本软件自动接收并记录的您的手机上的信息，包括但不限于您的健康数据、使用的语言、访问日期和时间等数据；</p><h3 id="2-信息的使用"><a href="#2-信息的使用" class="headerlink" title="2.信息的使用"></a>2.信息的使用</h3><p>a.在获得您的数据之后，本软件会将其上传至服务器，以便您能够更好地使用服务。</p><h3 id="3-信息披露"><a href="#3-信息披露" class="headerlink" title="3.信息披露"></a>3.信息披露</h3><p>a.本软件不会将您的信息披露给不受信任的第三方。</p><p>b.根据法律的有关规定，或者行政或司法机构的要求，向第三方或者行政、司法机构披露；</p><p>c.如您出现违反中国有关法律、法规或者相关规则的情况，需要向第三方披露；</p><h3 id="4-信息存储和交换"><a href="#4-信息存储和交换" class="headerlink" title="4.信息存储和交换"></a>4.信息存储和交换</h3><p>本软件收集的有关您的信息和资料将保存在本软件及服务器上，这些信息和资料可能传送至您所在国家、地区或本软件收集信息和资料所在地的境外并在境外被访问、存储和展示。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本软件尊重并保护所有使用服务用户的个人隐私权。为了给您提供更准确、更有个性化的服务，本软件会按照本隐私权政策的规定使用和披露您的个人信息。但本软件将以高度的勤勉、审慎义务对待这些信息。除本隐私权政策另有规定外，在未征得您事先许可的情况下，本软件不会将这些信息对外披露或向第三
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>算法七：二叉树遍历</title>
    <link href="http://guohuaden.com/2019/01/08/Arithmetic7-BinaryTreeTraverse/"/>
    <id>http://guohuaden.com/2019/01/08/Arithmetic7-BinaryTreeTraverse/</id>
    <published>2019-01-08T12:40:33.000Z</published>
    <updated>2019-01-15T07:44:33.644Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="http://guohuaden.com/categories/algorithm/"/>
    
    
      <category term="算法" scheme="http://guohuaden.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法六：K最近邻算法</title>
    <link href="http://guohuaden.com/2019/01/07/Arithmetic6-KNN/"/>
    <id>http://guohuaden.com/2019/01/07/Arithmetic6-KNN/</id>
    <published>2019-01-07T13:38:58.000Z</published>
    <updated>2019-01-15T07:43:37.612Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="http://guohuaden.com/categories/algorithm/"/>
    
    
      <category term="算法" scheme="http://guohuaden.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法五：迪克特斯拉算法</title>
    <link href="http://guohuaden.com/2019/01/06/Arithmetic5-Dijkstra/"/>
    <id>http://guohuaden.com/2019/01/06/Arithmetic5-Dijkstra/</id>
    <published>2019-01-06T14:38:27.000Z</published>
    <updated>2019-01-15T07:42:36.520Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="http://guohuaden.com/categories/algorithm/"/>
    
    
      <category term="算法" scheme="http://guohuaden.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法四：广度优先搜索和深度优先搜索</title>
    <link href="http://guohuaden.com/2019/01/05/Arithmetic4-BFSAndDFS/"/>
    <id>http://guohuaden.com/2019/01/05/Arithmetic4-BFSAndDFS/</id>
    <published>2019-01-05T13:37:34.000Z</published>
    <updated>2019-01-15T07:41:56.637Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="http://guohuaden.com/categories/algorithm/"/>
    
    
      <category term="算法、基础算法" scheme="http://guohuaden.com/tags/%E7%AE%97%E6%B3%95%E3%80%81%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法三：动态规划</title>
    <link href="http://guohuaden.com/2019/01/03/Arithmetic3-DynamicProgramming/"/>
    <id>http://guohuaden.com/2019/01/03/Arithmetic3-DynamicProgramming/</id>
    <published>2019-01-03T13:32:21.000Z</published>
    <updated>2019-01-15T07:35:58.553Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="http://guohuaden.com/categories/algorithm/"/>
    
    
      <category term="基础算法、算法" scheme="http://guohuaden.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E3%80%81%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法：选择排序</title>
    <link href="http://guohuaden.com/2018/12/31/Arithmetic-Basice-SelectSort/"/>
    <id>http://guohuaden.com/2018/12/31/Arithmetic-Basice-SelectSort/</id>
    <published>2018-12-31T12:52:49.000Z</published>
    <updated>2019-01-15T07:58:28.548Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="基础算法" scheme="http://guohuaden.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="基础算法" scheme="http://guohuaden.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法：插入排序</title>
    <link href="http://guohuaden.com/2018/12/30/Arithmetic-Basice-InsertSort/"/>
    <id>http://guohuaden.com/2018/12/30/Arithmetic-Basice-InsertSort/</id>
    <published>2018-12-30T13:10:56.000Z</published>
    <updated>2019-01-15T07:56:32.133Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="基础算法" scheme="http://guohuaden.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="基础算法" scheme="http://guohuaden.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法基础二：递归和for循环</title>
    <link href="http://guohuaden.com/2018/12/01/Arithmetic2-RecursionAndFor/"/>
    <id>http://guohuaden.com/2018/12/01/Arithmetic2-RecursionAndFor/</id>
    <published>2018-12-01T13:05:51.000Z</published>
    <updated>2019-01-15T07:36:13.468Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="http://guohuaden.com/categories/algorithm/"/>
    
    
      <category term="基础算法" scheme="http://guohuaden.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法：交换排序</title>
    <link href="http://guohuaden.com/2018/11/29/Arithmetic-Basice-ExchangeSort/"/>
    <id>http://guohuaden.com/2018/11/29/Arithmetic-Basice-ExchangeSort/</id>
    <published>2018-11-29T12:54:23.000Z</published>
    <updated>2019-01-15T07:55:49.911Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="基础算法" scheme="http://guohuaden.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="基础算法" scheme="http://guohuaden.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>基础算法一：排序</title>
    <link href="http://guohuaden.com/2018/11/28/Arithmetic-basics/"/>
    <id>http://guohuaden.com/2018/11/28/Arithmetic-basics/</id>
    <published>2018-11-28T12:14:26.000Z</published>
    <updated>2019-01-15T07:17:41.450Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="算法" scheme="http://guohuaden.com/categories/algorithm/"/>
    
    
      <category term="基础算法" scheme="http://guohuaden.com/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 七 （SDWebImageTransition）</title>
    <link href="http://guohuaden.com/2018/10/30/Read-SDWebImage-SDWebImageTransition/"/>
    <id>http://guohuaden.com/2018/10/30/Read-SDWebImage-SDWebImageTransition/</id>
    <published>2018-10-30T13:32:19.000Z</published>
    <updated>2018-11-02T08:04:14.448Z</updated>
    
    <content type="html"><![CDATA[<p>该类用于在视图类别加载图像完成后提供过渡动画。 </p><ol><li><p>在<code>UIVit + WebCache.h</code> 中的 <code>sd_imageTransition</code><br> 用于<code>UIKit(iOS和tvOS)</code>，使用<br> <code>+ [UIView transitionWithView：duration：options：animations：completion]</code> 进行过渡动画。 </p></li><li><p>对于<code>AppKit(macOS)</code><br>使用 <code>+ [NSAnimationContext runAnimationGroup：completionHandler：]</code>进行过渡动画。 我们可以调用<code>+ [NSAnimationContext currentContext]</code>来获取动画块中的上下文。 提供这些转换以用于基本用途。 </p></li></ol><ol start="3"><li>如果需要复杂的动画，可以考虑直接使用<code>Core Animation</code>或使用<code>SDWebImageAvoidAutoSetImage</code>并实现自己的后映像加载完成。<a id="more"></a></li></ol><h3 id="动画选项"><a href="#动画选项" class="headerlink" title="动画选项"></a>动画选项</h3><p>分两种情况，如果是 SD_UIKIT 类型，就直接使用系统的动画选项，否则定义的枚举类型只有一种隐式动画</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if SD_UIKIT</span><br><span class="line">typedef UIViewAnimationOptions SDWebImageAnimationOptions;</span><br><span class="line">#else</span><br><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageAnimationOptions) &#123;</span><br><span class="line">    SDWebImageAnimationOptionAllowsImplicitAnimation = 1 &lt;&lt; 0, // specify `allowsImplicitAnimation` for the `NSAnimationContext`</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="三个block代码块"><a href="#三个block代码块" class="headerlink" title="三个block代码块"></a>三个block代码块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//用于动画开始之前要执行的代码块</span><br><span class="line">typedef void (^SDWebImageTransitionPreparesBlock)(__kindof UIView * _Nonnull view, UIImage * _Nullable image, NSData * _Nullable imageData, SDImageCacheType cacheType, NSURL * _Nullable imageURL);</span><br><span class="line"></span><br><span class="line">//用于控制展示动画的代码块</span><br><span class="line">typedef void (^SDWebImageTransitionAnimationsBlock)(__kindof UIView * _Nonnull view, UIImage * _Nullable image);</span><br><span class="line"></span><br><span class="line">//用于动画结束后要执行的代码块</span><br><span class="line">typedef void (^SDWebImageTransitionCompletionBlock)(BOOL finished);</span><br></pre></td></tr></table></figure><h3 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//默认情况下，我们将图像设置为动画开头的视图。 您可以禁用此功能并提供自定义设置图像处理</span><br><span class="line">@property (nonatomic, assign) BOOL avoidAutoSetImage;</span><br><span class="line"></span><br><span class="line">//过渡动画的持续时间，以秒为单位。 默认为0.5。</span><br><span class="line">@property (nonatomic, assign) NSTimeInterval duration;</span><br><span class="line"></span><br><span class="line">//用于此过渡动画（macOS）中所有动画的计时功能。</span><br><span class="line">@property (nonatomic, strong, nullable) CAMediaTimingFunction *timingFunction NS_AVAILABLE_MAC(10_7);</span><br><span class="line"></span><br><span class="line">//一个动画选项</span><br><span class="line">@property (nonatomic, assign) SDWebImageAnimationOptions animationOptions;</span><br><span class="line"></span><br><span class="line">//动画开始前所要执行的代码块</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageTransitionPreparesBlock prepares;</span><br><span class="line"></span><br><span class="line">动画代码块</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageTransitionAnimationsBlock animations;</span><br><span class="line"></span><br><span class="line">//动画结束时要执行的代码块。</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageTransitionCompletionBlock completion;</span><br></pre></td></tr></table></figure><h3 id="Conveniences分类"><a href="#Conveniences分类" class="headerlink" title="Conveniences分类"></a>Conveniences分类</h3><p>创建过渡的便捷方式 如果需要，请记住指定持续时间。 对于UIKit，这些转换只使用对应的<code>animationOptions</code>。 默认情况下，我们启用<code>UIViewAnimationOptionAllowUserInteraction</code>以允许用户在转换期间进行交互。 对于AppKit，这些过渡在“动画”中使用了Core Animation。 因此，您的视图必须是图层支持的。 在应用之前设置<code>wantsLayer = YES</code>。</p><h4 id="公共属性和方法"><a href="#公共属性和方法" class="headerlink" title="公共属性和方法"></a>公共属性和方法</h4><p>调用不同的类属性获取不同的动画效果，如果类属性不可用，就调用类方法类获取不同的动画效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#if __has_feature(objc_class_property)</span><br><span class="line">/// 淡出过渡。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *fadeTransition;</span><br><span class="line">/// 从左转换翻转。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *flipFromLeftTransition;</span><br><span class="line">/// 从右转换翻转。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *flipFromRightTransition;</span><br><span class="line">/// 从顶部过渡翻转。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *flipFromTopTransition;</span><br><span class="line">/// 从底部过渡翻转。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *flipFromBottomTransition;</span><br><span class="line">/// 卷起过渡。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *curlUpTransition;</span><br><span class="line">/// 向下弯曲过渡。</span><br><span class="line">@property (nonatomic, class, nonnull, readonly) SDWebImageTransition *curlDownTransition;</span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">+ (nonnull instancetype)fadeTransition;</span><br><span class="line">+ (nonnull instancetype)flipFromLeftTransition;</span><br><span class="line">+ (nonnull instancetype)flipFromRightTransition;</span><br><span class="line">+ (nonnull instancetype)flipFromTopTransition;</span><br><span class="line">+ (nonnull instancetype)flipFromBottomTransition;</span><br><span class="line">+ (nonnull instancetype)curlUpTransition;</span><br><span class="line">+ (nonnull instancetype)curlDownTransition;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h3><p><code>SDWebImageTransition</code> 只有一个初始化方法，设置了动画时间为0.5秒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@implementation SDWebImageTransition</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        self.duration = 0.5;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>SDWebImageTransition 分类中创建了不同的动画,这里区别了SD_UIKIT 和 其他。（即iOS 、tvOS、部分watchOS ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">+ (SDWebImageTransition *)fadeTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionCrossDissolve | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionFade;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)flipFromLeftTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionFlipFromLeft | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionPush;</span><br><span class="line">        trans.subtype = kCATransitionFromLeft;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)flipFromRightTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionFlipFromRight | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionPush;</span><br><span class="line">        trans.subtype = kCATransitionFromRight;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)flipFromTopTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionFlipFromTop | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionPush;</span><br><span class="line">        trans.subtype = kCATransitionFromTop;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)flipFromBottomTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionFlipFromBottom | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionPush;</span><br><span class="line">        trans.subtype = kCATransitionFromBottom;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)curlUpTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionCurlUp | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionReveal;</span><br><span class="line">        trans.subtype = kCATransitionFromTop;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SDWebImageTransition *)curlDownTransition &#123;</span><br><span class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">    transition.animationOptions = UIViewAnimationOptionTransitionCurlDown | UIViewAnimationOptionAllowUserInteraction;</span><br><span class="line">#else</span><br><span class="line">    transition.animations = ^(__kindof NSView * _Nonnull view, NSImage * _Nullable image) &#123;</span><br><span class="line">        CATransition *trans = [CATransition animation];</span><br><span class="line">        trans.type = kCATransitionReveal;</span><br><span class="line">        trans.subtype = kCATransitionFromBottom;</span><br><span class="line">        [view.layer addAnimation:trans forKey:kCATransition];</span><br><span class="line">    &#125;;</span><br><span class="line">#endif</span><br><span class="line">    return transition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该类用于在视图类别加载图像完成后提供过渡动画。 &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;UIVit + WebCache.h&lt;/code&gt; 中的 &lt;code&gt;sd_imageTransition&lt;/code&gt;&lt;br&gt; 用于&lt;code&gt;UIKit(iOS和tvOS)&lt;/code&gt;，使用&lt;br&gt; &lt;code&gt;+ [UIView transitionWithView：duration：options：animations：completion]&lt;/code&gt; 进行过渡动画。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于&lt;code&gt;AppKit(macOS)&lt;/code&gt;&lt;br&gt;使用 &lt;code&gt;+ [NSAnimationContext runAnimationGroup：completionHandler：]&lt;/code&gt;进行过渡动画。 我们可以调用&lt;code&gt;+ [NSAnimationContext currentContext]&lt;/code&gt;来获取动画块中的上下文。 提供这些转换以用于基本用途。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;如果需要复杂的动画，可以考虑直接使用&lt;code&gt;Core Animation&lt;/code&gt;或使用&lt;code&gt;SDWebImageAvoidAutoSetImage&lt;/code&gt;并实现自己的后映像加载完成。
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 六 （SDWebImagePrefetcher）</title>
    <link href="http://guohuaden.com/2018/10/27/Read-SDWebImage-SDWebImagePrefetcher/"/>
    <id>http://guohuaden.com/2018/10/27/Read-SDWebImage-SDWebImagePrefetcher/</id>
    <published>2018-10-27T14:32:36.000Z</published>
    <updated>2018-11-02T08:04:38.551Z</updated>
    
    <content type="html"><![CDATA[<p><code>SDWebImagePrefetcher</code> 预先下载（预加载）图片，以方便后续使用，主要是用于部分图片需要先行下载并存储的情况。预先取出缓存中的一些URLs以供将来使用。 图像以低优先级下载。</p><p><code>SDWebImagePrefetcher</code> 设计了两种回调方式：</p><ol><li><p><code>SDWebImagePrefetcherDelegate</code><br>用来处理每一个预下载完成的回调，以及所有下载完成的回调 </p></li><li><p><code>block</code><br>用来处理整体进度的回调，返回的是下载完成的数量和总数量等</p></li></ol><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@protocol SDWebImagePrefetcherDelegate &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 在预加载图片时调用。</span><br><span class="line"> *</span><br><span class="line"> * @param imagePrefetcher 当前图片预加载类</span><br><span class="line"> * @param imageURL       预加载的图片网址</span><br><span class="line"> * @param finishedCount   预加载的图片总数（成功与否）</span><br><span class="line"> * @param totalCount      预加载的图片总数</span><br><span class="line"> */</span><br><span class="line">- (void)imagePrefetcher:(nonnull SDWebImagePrefetcher *)imagePrefetcher didPrefetchURL:(nullable NSURL *)imageURL finishedCount:(NSUInteger)finishedCount totalCount:(NSUInteger)totalCount;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 在预加载所有图像时调用。</span><br><span class="line"> * @param imagePrefetcher 当前图片的预加载类</span><br><span class="line"> * @param totalCount      预加载的图片总数（无论是否成功）</span><br><span class="line"> * @param skippedCount    跳过的图片总数</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">- (void)imagePrefetcher:(nonnull SDWebImagePrefetcher *)imagePrefetcher didFinishWithTotalCount:(NSUInteger)totalCount skippedCount:(NSUInteger)skippedCount;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="两个block代码块"><a href="#两个block代码块" class="headerlink" title="两个block代码块"></a>两个block代码块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 预加载进度block</span><br><span class="line"> @param noOfFinishedUrls 已经完成的数量，无论成功失败</span><br><span class="line"> @param noOfTotalUrls    总数量</span><br><span class="line"> */</span><br><span class="line">typedef void(^SDWebImagePrefetcherProgressBlock)(NSUInteger noOfFinishedUrls, NSUInteger noOfTotalUrls);</span><br><span class="line">/**</span><br><span class="line"> 预加载完成block</span><br><span class="line"></span><br><span class="line"> @param noOfFinishedUrls 已经完成的数量，无论成功失败</span><br><span class="line"> @param noOfSkippedUrls  跳过的数量</span><br><span class="line"> */</span><br><span class="line">typedef void(^SDWebImagePrefetcherCompletionBlock)(NSUInteger noOfFinishedUrls, NSUInteger noOfSkippedUrls);</span><br></pre></td></tr></table></figure><h3 id="属性声明"><a href="#属性声明" class="headerlink" title="属性声明"></a>属性声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 网络图片管理器,只读</span><br><span class="line"> */</span><br><span class="line">@property (strong, nonatomic, readonly, nonnull) SDWebImageManager *manager;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *同时预加载的最大URL数。 默认为3。</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign) NSUInteger maxConcurrentDownloads;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 预加载的SDWebImageOptions选项。 默认为SDWebImageLowPriority。</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign) SDWebImageOptions options;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Prefetcher的队列选项。 默认为主队列。</span><br><span class="line"> */</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_queue_t prefetcherQueue;</span><br><span class="line"></span><br><span class="line">//协议</span><br><span class="line">@property (weak, nonatomic, nullable) id &lt;SDWebImagePrefetcherDelegate&gt; delegate;</span><br></pre></td></tr></table></figure><h3 id="方法声明"><a href="#方法声明" class="headerlink" title="方法声明"></a>方法声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回全局图像预加载实例。</span><br><span class="line"> */</span><br><span class="line">+ (nonnull instancetype)sharedImagePrefetcher;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 允许您使用任意图像管理器实例化预加载类。</span><br><span class="line"> */</span><br><span class="line">- (nonnull instancetype)initWithImageManager:(nonnull SDWebImageManager *)manager NS_DESIGNATED_INITIALIZER;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 分配URL列表以让SDWebImagePrefetcher对预加载进行排队</span><br><span class="line"> * 目前一次下载一张图片，并跳过下载失败的图像，然后进入列表中的下一个图像。任何先前运行的预加载操作都将被取消。</span><br><span class="line"> * @param urls 预加载的URL列表</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">- (void)prefetchURLs:(nullable NSArray&lt;NSURL *&gt; *)urls;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 分配URL列表以让SDWebImagePrefetcher对预加载进行排队，目前一次下载一张图片，并跳过下载失败的图像，然后进入列表中的下一个图像。任何先前运行的预加载操作都将被取消。</span><br><span class="line"> * currently one image is downloaded at a time,</span><br><span class="line"> * and skips images for failed downloads and proceed to the next image in the list.</span><br><span class="line"> * Any previously-running prefetch operations are canceled.</span><br><span class="line"> *</span><br><span class="line"> * @param urls           预加载的URL列表</span><br><span class="line"> * @param progressBlock   block块在进度更新时被调用;</span><br><span class="line"> *                        第一个参数是已完成（成功或未成功）请求的数量，</span><br><span class="line"> *                        第二个参数是最初请求预加载的图像总数</span><br><span class="line"> * @param completionBlock Block块在预加载完成时被调用</span><br><span class="line"> *                       第一个参数是已完成（成功或未成功）请求的数量，</span><br><span class="line"> *                        第二个参数是跳过的请求数</span><br><span class="line"> */</span><br><span class="line">- (void)prefetchURLs:(nullable NSArray&lt;NSURL *&gt; *)urls</span><br><span class="line">            progress:(nullable SDWebImagePrefetcherProgressBlock)progressBlock</span><br><span class="line">           completed:(nullable SDWebImagePrefetcherCompletionBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 删除并取消排队列表</span><br><span class="line"> */</span><br><span class="line">- (void)cancelPrefetching;</span><br></pre></td></tr></table></figure><h3 id="私有属性声明"><a href="#私有属性声明" class="headerlink" title="私有属性声明"></a>私有属性声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//.h文件manager管理器声明为只读，这里声明为读写类型。实现外部只能访问，内部可读写。</span><br><span class="line">@property (strong, nonatomic, nonnull) SDWebImageManager *manager;</span><br><span class="line">//可以从不同的队列访问</span><br><span class="line">@property (strong, atomic, nullable) NSArray&lt;NSURL *&gt; *prefetchURLs; </span><br><span class="line"></span><br><span class="line">//已请求的数量</span><br><span class="line">@property (assign, nonatomic) NSUInteger requestedCount;</span><br><span class="line">//已跳过的数量</span><br><span class="line">@property (assign, nonatomic) NSUInteger skippedCount;</span><br><span class="line">//已完成的数量</span><br><span class="line">@property (assign, nonatomic) NSUInteger finishedCount;</span><br><span class="line">//已开始的时间</span><br><span class="line">@property (assign, nonatomic) NSTimeInterval startedTime;</span><br><span class="line">//预加载图片完成代码块</span><br><span class="line">@property (copy, nonatomic, nullable) SDWebImagePrefetcherCompletionBlock completionBlock;</span><br><span class="line">//预加载图片进度代码块</span><br><span class="line">@property (copy, nonatomic, nullable) SDWebImagePrefetcherProgressBlock progressBlock;</span><br></pre></td></tr></table></figure><h3 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h3><p>初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ (nonnull instancetype)sharedImagePrefetcher &#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    static id instance;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">        instance = [self new];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)init &#123;</span><br><span class="line">    return [self initWithImageManager:[SDWebImageManager new]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)initWithImageManager:(SDWebImageManager *)manager &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        //图片管理器</span><br><span class="line">        _manager = manager;</span><br><span class="line">        </span><br><span class="line">        预加载的SDWebImageOptions选项。 默认为SDWebImageLowPriority。</span><br><span class="line">        _options = SDWebImageLowPriority;</span><br><span class="line">        //Prefetcher的队列选项。 默认为主队列。</span><br><span class="line">        _prefetcherQueue = dispatch_get_main_queue();</span><br><span class="line">        //同时预加载的最大URL数。 默认为3。</span><br><span class="line">        self.maxConcurrentDownloads = 3;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性get和set方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//同时预加载的最大数的set方法</span><br><span class="line">- (void)setMaxConcurrentDownloads:(NSUInteger)maxConcurrentDownloads &#123;</span><br><span class="line">    self.manager.imageDownloader.maxConcurrentDownloads = maxConcurrentDownloads;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//同时预加载的最大数的get方法</span><br><span class="line">- (NSUInteger)maxConcurrentDownloads &#123;</span><br><span class="line">    return self.manager.imageDownloader.maxConcurrentDownloads;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预加载图片实现方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">- (void)startPrefetchingAtIndex:(NSUInteger)index &#123;</span><br><span class="line">    //创建临时变量，用于存储当前的URL</span><br><span class="line">    NSURL *currentURL;</span><br><span class="line">    </span><br><span class="line">    //同步锁，判断index是否越界，如果越界就返回，否则获取当前的URL，赋值给临时变量currentURL，已请求的数量+1</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        if (index &gt;= self.prefetchURLs.count) return;</span><br><span class="line">        currentURL = self.prefetchURLs[index];</span><br><span class="line">        self.requestedCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //图片管理器加载当前URL的图片</span><br><span class="line">    [self.manager loadImageWithURL:currentURL options:self.options progress:nil completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;</span><br><span class="line">        </span><br><span class="line">        //如果已经完成，返回</span><br><span class="line">        if (!finished) return;</span><br><span class="line">        </span><br><span class="line">        //完成的记数+1</span><br><span class="line">        self.finishedCount++;</span><br><span class="line"></span><br><span class="line">        //如果需要过程回调，执行过程回调操作</span><br><span class="line">        if (self.progressBlock) &#123;</span><br><span class="line">            self.progressBlock(self.finishedCount,(self.prefetchURLs).count);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果图片不存在，跳过的记数+1</span><br><span class="line">        if (!image) &#123;</span><br><span class="line">            // Add last failed</span><br><span class="line">            self.skippedCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果delegate存在，执行delegate方法</span><br><span class="line">        if ([self.delegate respondsToSelector:@selector(imagePrefetcher:didPrefetchURL:finishedCount:totalCount:)]) &#123;</span><br><span class="line">            [self.delegate imagePrefetcher:self</span><br><span class="line">                            didPrefetchURL:currentURL</span><br><span class="line">                             finishedCount:self.finishedCount</span><br><span class="line">                                totalCount:self.prefetchURLs.count</span><br><span class="line">             ];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果预下载的URLs数量大于已经下载的数量，就说明还有没下载完的任务，继续下载下一个。（这里是使用的递归方法）</span><br><span class="line">        if (self.prefetchURLs.count &gt; self.requestedCount) &#123;</span><br><span class="line">            dispatch_async(self.prefetcherQueue, ^&#123;</span><br><span class="line">                // 我们需要调度来避免函数递归调用。 即使对于巨大的URL列表，这也可以防止堆栈溢出</span><br><span class="line">                [self startPrefetchingAtIndex:self.requestedCount];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; else if (self.finishedCount == self.requestedCount) &#123; //如果预下载的URLs数量等于已经下载的数量，说明已经下载完。</span><br><span class="line">        </span><br><span class="line">            //执行预加载完成的delegate方法。</span><br><span class="line">            [self reportStatus];</span><br><span class="line">            </span><br><span class="line">            //如果有需要，执行完成block回调</span><br><span class="line">            if (self.completionBlock) &#123;</span><br><span class="line">                self.completionBlock(self.finishedCount, self.skippedCount);</span><br><span class="line">                </span><br><span class="line">                //将self.completionBlock 置空</span><br><span class="line">                self.completionBlock = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            //将self.progressBlock 置空</span><br><span class="line">            self.progressBlock = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//预加载完成状态的delegate方法</span><br><span class="line">- (void)reportStatus &#123;</span><br><span class="line">    NSUInteger total = (self.prefetchURLs).count;</span><br><span class="line">    if ([self.delegate respondsToSelector:@selector(imagePrefetcher:didFinishWithTotalCount:skippedCount:)]) &#123;</span><br><span class="line">        [self.delegate imagePrefetcher:self</span><br><span class="line">               didFinishWithTotalCount:(total - self.skippedCount)</span><br><span class="line">                          skippedCount:self.skippedCount</span><br><span class="line">         ];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配URL列表使得SDWebImagePrefetcher来安排预加载队列，当前同一时间下载一张图片，忽略下载时间的图片并继续执行列表中的下一张图片。任何之前执行的预加载操作都会被取消。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//urls：预加载的URL列表。</span><br><span class="line">- (void)prefetchURLs:(nullable NSArray&lt;NSURL *&gt; *)urls &#123;</span><br><span class="line">    [self prefetchURLs:urls progress:nil completed:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)prefetchURLs:(nullable NSArray&lt;NSURL *&gt; *)urls</span><br><span class="line">            progress:(nullable SDWebImagePrefetcherProgressBlock)progressBlock</span><br><span class="line">           completed:(nullable SDWebImagePrefetcherCompletionBlock)completionBlock &#123;</span><br><span class="line">    //防止重复的预加载请求</span><br><span class="line">    [self cancelPrefetching]; </span><br><span class="line">    </span><br><span class="line">    //CFAbsoluteTimeGetCurrent() 返回网络时间同步的时钟时间</span><br><span class="line">    self.startedTime = CFAbsoluteTimeGetCurrent();</span><br><span class="line">    </span><br><span class="line">    //预加载的URL列表</span><br><span class="line">    self.prefetchURLs = urls;</span><br><span class="line">    </span><br><span class="line">    代码块</span><br><span class="line">    self.completionBlock = completionBlock;</span><br><span class="line">    self.progressBlock = progressBlock;</span><br><span class="line">    </span><br><span class="line">    //如果预加载的URL列表为空，直接回调完成代码块，没有完成的urls和没有跳过的urls都传0</span><br><span class="line">    if (urls.count == 0) &#123;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock(0,0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 从具有最大允许并发性的列表中的第一个图像开始预加载，然后执行预加载操作</span><br><span class="line">        NSUInteger listCount = self.prefetchURLs.count;</span><br><span class="line">        for (NSUInteger i = 0; i &lt; self.maxConcurrentDownloads &amp;&amp; self.requestedCount &lt; listCount; i++) &#123;</span><br><span class="line">            [self startPrefetchingAtIndex:i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>防止重复的预加载请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)cancelPrefetching &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        self.prefetchURLs = nil;</span><br><span class="line">        self.skippedCount = 0;</span><br><span class="line">        self.requestedCount = 0;</span><br><span class="line">        self.finishedCount = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    [self.manager cancelAll];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;SDWebImagePrefetcher&lt;/code&gt; 预先下载（预加载）图片，以方便后续使用，主要是用于部分图片需要先行下载并存储的情况。预先取出缓存中的一些URLs以供将来使用。 图像以低优先级下载。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SDWebImagePrefetcher&lt;/code&gt; 设计了两种回调方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;SDWebImagePrefetcherDelegate&lt;/code&gt;&lt;br&gt;用来处理每一个预下载完成的回调，以及所有下载完成的回调 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;block&lt;/code&gt;&lt;br&gt;用来处理整体进度的回调，返回的是下载完成的数量和总数量等&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 六（编码器五：SDWebImageGIFCoder）</title>
    <link href="http://guohuaden.com/2018/10/24/Read-SDWebImage-SDWebImageGIFCoder/"/>
    <id>http://guohuaden.com/2018/10/24/Read-SDWebImage-SDWebImageGIFCoder/</id>
    <published>2018-10-24T14:31:13.000Z</published>
    <updated>2018-10-30T07:54:59.419Z</updated>
    
    <content type="html"><![CDATA[<p><code>SDWebImage</code> 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（<code>SDWebImageCodersManager</code>）、编解码协议（<code>SDWebImageCoder</code> 和 <code>SDWebImageProgressiveCoder</code> ）、PNG/JPEG/TIFF编解码，解压缩，显示大图（<code>SDWebImageImageIOCoder</code>）、GIF编解码（<code>SDWebImageGIFCoder</code>）、WebP编解码（<code>SDWebImageWebPCoder</code>）以及辅助类（<code>SDWebImageCoderHelper</code>）。</p><p><code>SDWebImageImageIOCoder</code> ：内置编码器,该类遵守了 <code>SDWebImageCoder</code>协议，但并没有遵守 <code>SDWebImageProgressiveCoder</code>协议，说明该类仅针对git图片的编解码，并不支持git图片的逐行解码功能。<a id="more"></a></p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>判断图片格式是否支持编码，该类仅针对动图的操作，所以仅判断图片的格式是否为GIF格式，如果是返回YES，否则返回NO</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canEncodeToFormat:(SDImageFormat)format &#123;</span><br><span class="line">    return (format == SDImageFormatGIF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据给定的图片格式将图片进行编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">- (NSData *)encodedDataWithImage:(UIImage *)image format:(SDImageFormat)format &#123;</span><br><span class="line">    //如果image不存在，返回nil</span><br><span class="line">    if (!image) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //该类只支持动图的编解码，如果image的格式不是GIF，返回nil</span><br><span class="line">    if (format != SDImageFormatGIF) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //临时变量imageData，用来保存图片数据</span><br><span class="line">    NSMutableData *imageData = [NSMutableData data];</span><br><span class="line">    // 获取GIF图像格式的CFStringRef格式字符串</span><br><span class="line">    CFStringRef imageUTType = [NSData sd_UTTypeFromSDImageFormat:SDImageFormatGIF];</span><br><span class="line">    // 生成图片对象的SDWebImageFrame类型元素的数组</span><br><span class="line">    NSArray&lt;SDWebImageFrame *&gt; *frames = [SDWebImageCoderHelper framesFromAnimatedImage:image];</span><br><span class="line">    </span><br><span class="line">    // 创建图像目标。 GIF不支持EXIF图像方向</span><br><span class="line">    CGImageDestinationRef imageDestination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData, imageUTType, frames.count, NULL);</span><br><span class="line">    </span><br><span class="line">    //如果创建失败，返回nil</span><br><span class="line">    if (!imageDestination) &#123;</span><br><span class="line">        // Handle failure.</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if (frames.count == 0) &#123;</span><br><span class="line">        // 用于静态单个GIF图片（如果是单帧的动图就直接将图片添加到imageDestination中）</span><br><span class="line">        CGImageDestinationAddImage(imageDestination, image.CGImage, nil);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 用于动画的GIF图片</span><br><span class="line">        //// 获取到动图的循环次数</span><br><span class="line">        NSUInteger loopCount = image.sd_imageLoopCount;</span><br><span class="line">        </span><br><span class="line">        // 创建一个动图属性字典保存循环次数</span><br><span class="line">        NSDictionary *gifProperties = @&#123;(__bridge NSString *)kCGImagePropertyGIFDictionary: @&#123;(__bridge NSString *)kCGImagePropertyGIFLoopCount : @(loopCount)&#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        // 为图像目标设置属性</span><br><span class="line">        CGImageDestinationSetProperties(imageDestination, (__bridge CFDictionaryRef)gifProperties);</span><br><span class="line">        </span><br><span class="line">        //循环每一帧的图拼啊</span><br><span class="line">        for (size_t i = 0; i &lt; frames.count; i++) &#123;</span><br><span class="line">             // 获取SDWebImageFrame对象</span><br><span class="line">            SDWebImageFrame *frame = frames[i];</span><br><span class="line">            </span><br><span class="line">            //获取没一帧的显示时间</span><br><span class="line">            float frameDuration = frame.duration;</span><br><span class="line">            </span><br><span class="line">            //获取每一帧取位图图片</span><br><span class="line">            CGImageRef frameImageRef = frame.image.CGImage;</span><br><span class="line">            </span><br><span class="line">            // 创建一个临时变量字典保存每一帧的展示时间</span><br><span class="line">            NSDictionary *frameProperties = @&#123;(__bridge NSString *)kCGImagePropertyGIFDictionary : @&#123;(__bridge NSString *)kCGImagePropertyGIFDelayTime : @(frameDuration)&#125;&#125;;</span><br><span class="line">            </span><br><span class="line">            // 将位图和其对应的属性添加到imageDestination中</span><br><span class="line">            CGImageDestinationAddImage(imageDestination, frameImageRef, (__bridge CFDictionaryRef)frameProperties);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果编码失败就返回nil</span><br><span class="line">    if (CGImageDestinationFinalize(imageDestination) == NO) &#123;</span><br><span class="line">       </span><br><span class="line">        imageData = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 释放imageDestination对象</span><br><span class="line">    CFRelease(imageDestination);</span><br><span class="line">    </span><br><span class="line">    返回图片数据</span><br><span class="line">    return [imageData copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p>判断是否支持图片数据的解码<br>该类仅针对动图的操作，所以仅判断图片的格式是否为GIF格式，如果是支持该图片数据解码，否则返回NO</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canDecodeFromData:(nullable NSData *)data &#123;</span><br><span class="line">    return ([NSData sd_imageFormatForImageData:data] == SDImageFormatGIF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将图片数据解码为图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)decodedImageWithData:(NSData *)data &#123;</span><br><span class="line">    //如果数据为空，返回nil</span><br><span class="line">    if (!data) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">#if SD_MAC</span><br><span class="line">    SDAnimatedImageRep *imageRep = [[SDAnimatedImageRep alloc] initWithData:data];</span><br><span class="line">    NSImage *animatedImage = [[NSImage alloc] initWithSize:imageRep.size];</span><br><span class="line">    [animatedImage addRepresentation:imageRep];</span><br><span class="line">    return animatedImage;</span><br><span class="line">#else</span><br><span class="line">     // 生成图片源</span><br><span class="line">    CGImageSourceRef source = CGImageSourceCreateWithData((__bridge CFDataRef)data, NULL);</span><br><span class="line">    //如果图片源不存在，返回nil</span><br><span class="line">    if (!source) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 获取子图片数量</span><br><span class="line">    size_t count = CGImageSourceGetCount(source);</span><br><span class="line">    </span><br><span class="line">    // 创建临时变量，用来保存动图对象</span><br><span class="line">    UIImage *animatedImage;</span><br><span class="line">    </span><br><span class="line">    //如果子图片个数不大于2，直接将数据转化成图片</span><br><span class="line">    if (count &lt;= 1) &#123;</span><br><span class="line">        animatedImage = [[UIImage alloc] initWithData:data];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 创建可变数组保存SDWebImageFrame对象</span><br><span class="line">        NSMutableArray&lt;SDWebImageFrame *&gt; *frames = [NSMutableArray array];</span><br><span class="line">        </span><br><span class="line">        // 遍历子图片对象，并将其包装成SDWebImageFrame对象</span><br><span class="line">        for (size_t i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            // 获取指定帧数的相位图</span><br><span class="line">            CGImageRef imageRef = CGImageSourceCreateImageAtIndex(source, i, NULL);</span><br><span class="line">            // 如果没获取到就跳过进入下次循环</span><br><span class="line">            if (!imageRef) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 获取指定帧数的持续时间</span><br><span class="line">            float duration = [self sd_frameDurationAtIndex:i source:source];</span><br><span class="line">            </span><br><span class="line">            // 根据相位图生成图片对象</span><br><span class="line">            UIImage *image = [[UIImage alloc] initWithCGImage:imageRef];</span><br><span class="line">            </span><br><span class="line">            // 释放相位图</span><br><span class="line">            CGImageRelease(imageRef);</span><br><span class="line">            </span><br><span class="line">            // 将一帧的信息封装成SDWebImageFrame对象</span><br><span class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:image duration:duration];</span><br><span class="line">            </span><br><span class="line">            // 将封装好的SDWebImageFrame对象添加到数组中保存</span><br><span class="line">            [frames addObject:frame];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 创建临时变量，用来保存循环次数</span><br><span class="line">        NSUInteger loopCount = 1;</span><br><span class="line">        </span><br><span class="line">        // 获取到图片属性</span><br><span class="line">        NSDictionary *imageProperties = (__bridge_transfer NSDictionary *)CGImageSourceCopyProperties(source, nil);</span><br><span class="line">        </span><br><span class="line">        // 获取到GIF相关的图像属性</span><br><span class="line">        NSDictionary *gifProperties = [imageProperties valueForKey:(__bridge NSString *)kCGImagePropertyGIFDictionary];</span><br><span class="line">        </span><br><span class="line">        如果gifProperties存在</span><br><span class="line">        if (gifProperties) &#123;</span><br><span class="line">            //获取GIF循环次数</span><br><span class="line">            NSNumber *gifLoopCount = [gifProperties valueForKey:(__bridge NSString *)kCGImagePropertyGIFLoopCount];</span><br><span class="line">            </span><br><span class="line">            //如果可以转换成NSNumber类型，就将获取到的GIF循环次数赋值给loopCount</span><br><span class="line">            if (gifLoopCount != nil) &#123;</span><br><span class="line">                loopCount = gifLoopCount.unsignedIntegerValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 利用封装好的SDWebImageFrame对象数组生成动图对象</span><br><span class="line">        animatedImage = [SDWebImageCoderHelper animatedImageWithFrames:frames];</span><br><span class="line">        // 设置动图对象的循环次数</span><br><span class="line">        animatedImage.sd_imageLoopCount = loopCount;</span><br><span class="line">        //设置动图的图片格式</span><br><span class="line">        animatedImage.sd_imageFormat = SDImageFormatGIF;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //释放图片源source</span><br><span class="line">    CFRelease(source);</span><br><span class="line">    </span><br><span class="line">    //返回动图</span><br><span class="line">    return animatedImage;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果执行动图的解压操作，就直接返回该图片，动图不支持解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)decompressedImageWithImage:(UIImage *)image</span><br><span class="line">                                   data:(NSData *__autoreleasing  _Nullable *)data</span><br><span class="line">                                options:(nullable NSDictionary&lt;NSString*, NSObject*&gt;*)optionsDict &#123;</span><br><span class="line">    // GIF do not decompress</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><p>获取动图每一帧的显示时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (float)sd_frameDurationAtIndex:(NSUInteger)index source:(CGImageSourceRef)source &#123;</span><br><span class="line">    //临时变量每一帧的显示时间，默认为0.1f</span><br><span class="line">    float frameDuration = 0.1f;</span><br><span class="line">    </span><br><span class="line">    // 获取图片源中指定位置的图片属性</span><br><span class="line">    CFDictionaryRef cfFrameProperties = CGImageSourceCopyPropertiesAtIndex(source, index, nil);</span><br><span class="line">    //如果获取失败，就返回默认每一帧的显示时间</span><br><span class="line">    if (!cfFrameProperties) &#123;</span><br><span class="line">        return frameDuration;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    获取图片属性字典</span><br><span class="line">    NSDictionary *frameProperties = (__bridge NSDictionary *)cfFrameProperties;</span><br><span class="line">    //从图片属性中获取gif属性字典</span><br><span class="line">    NSDictionary *gifProperties = frameProperties[(NSString *)kCGImagePropertyGIFDictionary];</span><br><span class="line">    </span><br><span class="line">    //从git属性中获取当前帧的显示时间</span><br><span class="line">    NSNumber *delayTimeUnclampedProp = gifProperties[(NSString *)kCGImagePropertyGIFUnclampedDelayTime];</span><br><span class="line">    </span><br><span class="line">    //如果当前帧的显示时间不为nil，赋值给frameDuration</span><br><span class="line">    if (delayTimeUnclampedProp != nil) &#123;</span><br><span class="line">        frameDuration = [delayTimeUnclampedProp floatValue];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //如果通过key：kCGImagePropertyGIFUnclampedDelayTime 从gifProperties字典中获取不到当前帧的显示时间，则通过另一个key：kCGImagePropertyGIFDelayTime获取</span><br><span class="line">        NSNumber *delayTimeProp = gifProperties[(NSString *)kCGImagePropertyGIFDelayTime];</span><br><span class="line">        </span><br><span class="line">        //如果不为空，赋值给赋值给frameDuration</span><br><span class="line">        if (delayTimeProp != nil) &#123;</span><br><span class="line">            frameDuration = [delayTimeProp floatValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //许多烦人的广告指定0持续时间，以使图像尽快闪现。 我们遵循Firefox的行为，并为指定持续时间&lt;= 10 ms的任何帧使用100 ms的持续时间。</span><br><span class="line">    </span><br><span class="line">    如果当前帧显示的时间实现小于11ms，就重新设置为100ms</span><br><span class="line">    if (frameDuration &lt; 0.011f) &#123;</span><br><span class="line">        frameDuration = 0.100f;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //释放cfFrameProperties</span><br><span class="line">    CFRelease(cfFrameProperties);</span><br><span class="line">    </span><br><span class="line">    //返回当前帧显示时间</span><br><span class="line">    return frameDuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;SDWebImage&lt;/code&gt; 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（&lt;code&gt;SDWebImageCodersManager&lt;/code&gt;）、编解码协议（&lt;code&gt;SDWebImageCoder&lt;/code&gt; 和 &lt;code&gt;SDWebImageProgressiveCoder&lt;/code&gt; ）、PNG/JPEG/TIFF编解码，解压缩，显示大图（&lt;code&gt;SDWebImageImageIOCoder&lt;/code&gt;）、GIF编解码（&lt;code&gt;SDWebImageGIFCoder&lt;/code&gt;）、WebP编解码（&lt;code&gt;SDWebImageWebPCoder&lt;/code&gt;）以及辅助类（&lt;code&gt;SDWebImageCoderHelper&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SDWebImageImageIOCoder&lt;/code&gt; ：内置编码器,该类遵守了 &lt;code&gt;SDWebImageCoder&lt;/code&gt;协议，但并没有遵守 &lt;code&gt;SDWebImageProgressiveCoder&lt;/code&gt;协议，说明该类仅针对git图片的编解码，并不支持git图片的逐行解码功能。
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 六 （编码器四：SDWebImageImageIOCoder）</title>
    <link href="http://guohuaden.com/2018/10/23/Read-SDWebImage-SDWebImageImageIOCoder/"/>
    <id>http://guohuaden.com/2018/10/23/Read-SDWebImage-SDWebImageImageIOCoder/</id>
    <published>2018-10-23T13:57:30.000Z</published>
    <updated>2018-10-30T02:50:13.633Z</updated>
    
    <content type="html"><![CDATA[<p><code>SDWebImage</code> 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（<code>SDWebImageCodersManager</code>）、编解码协议（<code>SDWebImageCoder</code>）、PNG/JPEG/TIFF编解码，解压缩，显示大图（<code>SDWebImageImageIOCoder</code>）、GIF编解码（<code>SDWebImageGIFCoder</code>）、WebP编解码（<code>SDWebImageWebPCoder</code>）以及辅助类（<code>SDWebImageCoderHelper</code>）</p><p><code>SDWebImageImageIOCoder</code> ：内置编码器，支持PNG，JPEG，TIFF，支持逐行解码。该类遵守 <code>SDWebImageProgressiveCoder</code>协议。该协议也遵守<code>SDWebImageCoder</code>协议，所以这个类要实现这两个协议的方法。</p><p>  GIF<br>  还支持静态GIF（意思是只处理第一帧）。<br>  要获得完整的GIF支持，我们建议使用<code>FLAnimatedImage</code>或性能较差的<code>SDWebImageGIFCoder</code></p><p>  HEIC<br>  该编码器还支持HEIC格式，因为ImageIO本身支持它。但这取决于系统功能，因此无法在所有设备上运行。<a id="more"></a></p><h3 id="私有静态常量"><a href="#私有静态常量" class="headerlink" title="私有静态常量"></a>私有静态常量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//每像素字节数为4</span><br><span class="line">static const size_t kBytesPerPixel = 4;</span><br><span class="line">//每位字节数为8</span><br><span class="line">static const size_t kBitsPerComponent = 8;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">  *设置标志“SDWebImageScaleDownLargeImages”时，解码图像的最大大小（以MB为单位）</span><br><span class="line">  * iPad1和iPhone 3GS的建议值：60。</span><br><span class="line">  * iPad2和iPhone 4的建议值：120。</span><br><span class="line">  * iPhone 3G和iPod 2及早期设备的建议值：30。</span><br><span class="line"> */</span><br><span class="line">static const CGFloat kDestImageSizeMB = 60.0f;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *当设置标志“SDWebImageScaleDownLargeImages”时，定义用于解码图像的图块的最大大小（以MB为单位）</span><br><span class="line"> * iPad1和iPhone 3GS的建议值：20。</span><br><span class="line"> * iPad2和iPhone 4的建议值：40。</span><br><span class="line"> * iPhone 3G和iPod 2及早期设备的建议值：10。</span><br><span class="line">*/</span><br><span class="line">static const CGFloat kSourceImageTileSizeMB = 20.0f;</span><br><span class="line"></span><br><span class="line">//定义 1M = 1024.0f * 1024.0f</span><br><span class="line">static const CGFloat kBytesPerMB = 1024.0f * 1024.0f;</span><br><span class="line"></span><br><span class="line">//定义1MB的像素数是1MB的Bytes数量除以1像素的Bytes数</span><br><span class="line">static const CGFloat kPixelsPerMB = kBytesPerMB / kBytesPerPixel;</span><br><span class="line">//定义解码完的图像的最大像素总数数是解码完的图像最size乘以1MB的像素数</span><br><span class="line">static const CGFloat kDestTotalPixels = kDestImageSizeMB * kPixelsPerMB;</span><br><span class="line"></span><br><span class="line">//定义用于解码的图像的最大像素总数是解码的图像的size乘以1MB的像素数</span><br><span class="line">static const CGFloat kTileTotalPixels = kSourceImageTileSizeMB * kPixelsPerMB;</span><br><span class="line"></span><br><span class="line">//定义重叠像素大小为2像素</span><br><span class="line">static const CGFloat kDestSeemOverlap = 2.0f;</span><br></pre></td></tr></table></figure><h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        //定义了两个变量来保存图像的宽和高</span><br><span class="line">        size_t _width, _height;</span><br><span class="line">#if SD_UIKIT || SD_WATCH</span><br><span class="line">        //定义变量记录图片方向</span><br><span class="line">        UIImageOrientation _orientation;</span><br><span class="line">#endif</span><br><span class="line">        //定义变量记录图片源</span><br><span class="line">        CGImageSourceRef _imageSource;</span><br></pre></td></tr></table></figure><h3 id="life-cycle"><a href="#life-cycle" class="headerlink" title="life cycle"></a>life cycle</h3><p>单例方法和dealloc方法</p><p>C 语言不能够调用OC中的retain与release，一般的C 语言接口都提供了release函数（比如CGContextRelease(context c)）来管理内存。ARC不会自动调用这些C接口的函数，所以这还是需要我们自己来进行管理的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">    //如果CGImageSourceRef类型的_imageSource存在，在dealloc方法中手动释放掉（CGXXX 和CFXXX方法，ARC并不会自动释放，需要手动去释放掉）</span><br><span class="line">    </span><br><span class="line">    if (_imageSource) &#123;</span><br><span class="line">        CFRelease(_imageSource);</span><br><span class="line">        _imageSource = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//单例方法</span><br><span class="line">+ (instancetype)sharedCoder &#123;</span><br><span class="line">    static SDWebImageImageIOCoder *coder;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        coder = [[SDWebImageImageIOCoder alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><h4 id="SDWebImageCoder协议方法"><a href="#SDWebImageCoder协议方法" class="headerlink" title="SDWebImageCoder协议方法"></a><code>SDWebImageCoder</code>协议方法</h4><p>判断是否支持图片数据的解码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canDecodeFromData:(nullable NSData *)data &#123;</span><br><span class="line">    //通过NSData中的扩展方法：sd_imageFormatForImageData 获取图片的格式</span><br><span class="line">    switch ([NSData sd_imageFormatForImageData:data]) &#123;</span><br><span class="line">        case SDImageFormatWebP:</span><br><span class="line">            // 不支持WebP格式图片解码</span><br><span class="line">            return NO;</span><br><span class="line">        case SDImageFormatHEIC:</span><br><span class="line">            // 检查是否支持HEIC格式图片解码</span><br><span class="line">            return [[self class] canDecodeFromHEICFormat];</span><br><span class="line">        default:</span><br><span class="line">            return YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过图片数据（ImageData）解码获取图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)decodedImageWithData:(NSData *)data &#123;</span><br><span class="line">    //如果data为空，返回nil</span><br><span class="line">    if (!data) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //将imagedata转为图片</span><br><span class="line">    UIImage *image = [[UIImage alloc] initWithData:data];</span><br><span class="line">    //设置图片的格式</span><br><span class="line">    image.sd_imageFormat = [NSData sd_imageFormatForImageData:data];</span><br><span class="line">    </span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用原始图片和图片数据解压缩图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">使用原始图片和图片数据解压缩图片。</span><br><span class="line"></span><br><span class="line"> @param image 需要压缩的原图片</span><br><span class="line"> @param data 指向原始图像数据的指针。 指针本身是非空的，但图像数据可以为空。 如果需要，此数据将设置为缓存。 如果您不需要同时修改数据，请忽略此参数。</span><br><span class="line"> @param optionsDict 一个包含任何解压缩选项的字典。 通过&#123;SDWebImageCoderScaleDownLargeImagesKey：@（YES）&#125;缩小大图像</span><br><span class="line"> @return 解压缩后的图片</span><br><span class="line"> */</span><br><span class="line">- (UIImage *)decompressedImageWithImage:(UIImage *)image</span><br><span class="line">                                   data:(NSData *__autoreleasing  _Nullable *)data</span><br><span class="line">                                options:(nullable NSDictionary&lt;NSString*, NSObject*&gt;*)optionsDict &#123;</span><br><span class="line">                                </span><br><span class="line">//如果是mac，直接返回图片</span><br><span class="line">#if SD_MAC</span><br><span class="line">    return image;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">//如果是iOS 、osTV、osWatch</span><br><span class="line">#if SD_UIKIT || SD_WATCH</span><br><span class="line">    // 创建变量保存，默认是不缩小</span><br><span class="line">    BOOL shouldScaleDown = NO;</span><br><span class="line">    </span><br><span class="line">    // 如果传入选项字典参数</span><br><span class="line">    if (optionsDict != nil) &#123;</span><br><span class="line">        //创建临时变量保存选项值</span><br><span class="line">        NSNumber *scaleDownLargeImagesOption = nil;</span><br><span class="line">        //SDWebImageCoderScaleDownLargeImagesKey对应的value类型为NSNumber，则保存value</span><br><span class="line">        if ([optionsDict[SDWebImageCoderScaleDownLargeImagesKey] isKindOfClass:[NSNumber class]]) &#123;</span><br><span class="line">            scaleDownLargeImagesOption = (NSNumber *)optionsDict[SDWebImageCoderScaleDownLargeImagesKey];</span><br><span class="line">        &#125;</span><br><span class="line">        //如果选项值不为nil，转换成BOOL类型，并保存</span><br><span class="line">        if (scaleDownLargeImagesOption != nil) &#123;</span><br><span class="line">            shouldScaleDown = [scaleDownLargeImagesOption boolValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果不需要缩小图片，直接执行解压图片操作</span><br><span class="line">    if (!shouldScaleDown) &#123;</span><br><span class="line">        return [self sd_decompressedImageWithImage:image];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        如果需要缩小图片，则执行图片的解压和缩小操作</span><br><span class="line">        UIImage *scaledDownImage = [self sd_decompressedAndScaledDownImageWithImage:image];</span><br><span class="line">        </span><br><span class="line">         // 如果解压和缩小成功，仍处理数据指针，调用压缩方法</span><br><span class="line">        if (scaledDownImage &amp;&amp; !CGSizeEqualToSize(scaledDownImage.size, image.size)) &#123;</span><br><span class="line">            //根据图片数据指针得到图片的格式</span><br><span class="line">            SDImageFormat format = [NSData sd_imageFormatForImageData:*data];</span><br><span class="line">            //通过缩小的图片和图片格式编码获取imagedata</span><br><span class="line">            NSData *imageData = [self encodedDataWithImage:scaledDownImage format:format];</span><br><span class="line">            if (imageData) &#123;</span><br><span class="line">                // 通过参数回传处理后的图像数据</span><br><span class="line">                *data = imageData;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 返回处理后的图片</span><br><span class="line">        return scaledDownImage;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SDWebImageProgressiveCoder-协议方法"><a href="#SDWebImageProgressiveCoder-协议方法" class="headerlink" title="SDWebImageProgressiveCoder 协议方法"></a><code>SDWebImageProgressiveCoder</code> 协议方法</h4><p>判断是否支持增量解码某个data数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)canIncrementallyDecodeFromData:(NSData *)data &#123;</span><br><span class="line">    //获取图片的格式</span><br><span class="line">    switch ([NSData sd_imageFormatForImageData:data]) &#123;</span><br><span class="line">        case SDImageFormatWebP:</span><br><span class="line">            // 不支持WebP逐行解码</span><br><span class="line">            return NO;</span><br><span class="line">        case SDImageFormatHEIC:</span><br><span class="line">            // 检查HEIC解码兼容性</span><br><span class="line">            return [[self class] canDecodeFromHEICFormat];</span><br><span class="line">        default:</span><br><span class="line">            // 其他类型就返回YES</span><br><span class="line">            return YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将图片数据增量解码为图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)incrementallyDecodedImageWithData:(NSData *)data finished:(BOOL)finished &#123;</span><br><span class="line">    判断增量图片源是否存在，如果不存在，创建一个新的</span><br><span class="line">    if (!_imageSource) &#123;</span><br><span class="line">        _imageSource = CGImageSourceCreateIncremental(NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    UIImage *image;</span><br><span class="line">    </span><br><span class="line">    //更新数据源，这里必须传递所有数据，而不仅仅是新字节</span><br><span class="line">    CGImageSourceUpdateData(_imageSource, (__bridge CFDataRef)data, finished);</span><br><span class="line">    </span><br><span class="line">    // 获取到图像的宽、高和方向</span><br><span class="line">    if (_width + _height == 0) &#123;</span><br><span class="line">        CFDictionaryRef properties = CGImageSourceCopyPropertiesAtIndex(_imageSource, 0, NULL);</span><br><span class="line">        if (properties) &#123;</span><br><span class="line">            NSInteger orientationValue = 1;</span><br><span class="line">            CFTypeRef val = CFDictionaryGetValue(properties, kCGImagePropertyPixelHeight);</span><br><span class="line">            if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;_height);</span><br><span class="line">            val = CFDictionaryGetValue(properties, kCGImagePropertyPixelWidth);</span><br><span class="line">            if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;_width);</span><br><span class="line">            val = CFDictionaryGetValue(properties, kCGImagePropertyOrientation);</span><br><span class="line">            if (val) CFNumberGetValue(val, kCFNumberNSIntegerType, &amp;orientationValue);</span><br><span class="line">            CFRelease(properties);</span><br><span class="line">            </span><br><span class="line">            //当我们绘制到Core Graphics时，我们会丢失方向信息，这意味着initWithCGIImage生成的图像有时会导致错误定向。 （与didCompleteWithError中的initWithData生成的图像不同。）因此将其保存在此处并稍后传递。</span><br><span class="line">#if SD_UIKIT || SD_WATCH</span><br><span class="line">            _orientation = [SDWebImageCoderHelper imageOrientationFromEXIFOrientation:orientationValue];</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (_width + _height &gt; 0) &#123;</span><br><span class="line">        // 创建位图对象</span><br><span class="line">        CGImageRef partialImageRef = CGImageSourceCreateImageAtIndex(_imageSource, 0, NULL);</span><br><span class="line">        </span><br><span class="line">        //如果存在，则根据该位图生成图片</span><br><span class="line">        if (partialImageRef) &#123;</span><br><span class="line">#if SD_UIKIT || SD_WATCH</span><br><span class="line">            image = [[UIImage alloc] initWithCGImage:partialImageRef scale:1 orientation:_orientation];</span><br><span class="line">#elif SD_MAC</span><br><span class="line">            image = [[UIImage alloc] initWithCGImage:partialImageRef size:NSZeroSize];</span><br><span class="line">#endif</span><br><span class="line">            // 位图对象的引用计数-1</span><br><span class="line">            CGImageRelease(partialImageRef);</span><br><span class="line">            image.sd_imageFormat = [NSData sd_imageFormatForImageData:data];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     // 如果加载完成就释放掉位图对象，并置空</span><br><span class="line">    if (finished) &#123;</span><br><span class="line">        if (_imageSource) &#123;</span><br><span class="line">            CFRelease(_imageSource);</span><br><span class="line">            _imageSource = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //返回该图片</span><br><span class="line">    return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="私有方法中的：解压图片-和-解压并按比例缩小图片"><a href="#私有方法中的：解压图片-和-解压并按比例缩小图片" class="headerlink" title="私有方法中的：解压图片 和 解压并按比例缩小图片"></a>私有方法中的：解压图片 和 解压并按比例缩小图片</h4><p>解压图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#if SD_UIKIT || SD_WATCH</span><br><span class="line">- (nullable UIImage *)sd_decompressedImageWithImage:(nullable UIImage *)image &#123;</span><br><span class="line"></span><br><span class="line">    //如果图片不需要解码，直接返回image</span><br><span class="line">    if (![[self class] shouldDecodeImage:image]) &#123;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //自动释放位图上下文和所有变量以帮助系统在存在内存警告时释放内存。</span><br><span class="line">    //在iOS7上，别忘了调用[[SDImageCache sharedImageCache] clearMemory];</span><br><span class="line">    </span><br><span class="line">    // 建立自动释放池，以帮助系统在收到内存警告时释放内存。</span><br><span class="line">    @autoreleasepool&#123;</span><br><span class="line">        </span><br><span class="line">        //获取图片对象的位图图片</span><br><span class="line">        CGImageRef imageRef = image.CGImage;</span><br><span class="line">        // 获取图片对象的色彩空间</span><br><span class="line">        CGColorSpaceRef colorspaceRef = SDCGColorSpaceGetDeviceRGB();</span><br><span class="line">        BOOL hasAlpha = SDCGImageRefContainsAlpha(imageRef);</span><br><span class="line">        //  iOS 显示 Alpha（透明）信息  (BRGA8888/BGRX8888)</span><br><span class="line">        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line">        </span><br><span class="line">        size_t width = CGImageGetWidth(imageRef);</span><br><span class="line">        size_t height = CGImageGetHeight(imageRef);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        // CGBitmapContextCreate不支持kCGImageAlphaNone。由于此处的原始图像没有alpha信息，因此使用kCGImageAlphaNoneSkipLast创建没有alpha信息的位图图形上下文。</span><br><span class="line">        //创建位图图形上下文</span><br><span class="line">        CGContextRef context = CGBitmapContextCreate(NULL,</span><br><span class="line">                                                     width,</span><br><span class="line">                                                     height,</span><br><span class="line">                                                     kBitsPerComponent,</span><br><span class="line">                                                     0,</span><br><span class="line">                                                     colorspaceRef,</span><br><span class="line">                                                     bitmapInfo);</span><br><span class="line">        //如果创建失败，直接返回image</span><br><span class="line">        if (context == NULL) &#123;</span><br><span class="line">            return image;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 将图像绘制到上下文中并检索没有alpha的新位图图像</span><br><span class="line">        CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef);</span><br><span class="line">        // 生成位图图像</span><br><span class="line">        CGImageRef imageRefWithoutAlpha = CGBitmapContextCreateImage(context);</span><br><span class="line">        // 根据位图图像生成图片对象</span><br><span class="line">        UIImage *imageWithoutAlpha = [[UIImage alloc] initWithCGImage:imageRefWithoutAlpha scale:image.scale orientation:image.imageOrientation];</span><br><span class="line">        //释放掉上下文</span><br><span class="line">        CGContextRelease(context);</span><br><span class="line">        //释放掉位图图片</span><br><span class="line">        CGImageRelease(imageRefWithoutAlpha);</span><br><span class="line">        </span><br><span class="line">        //返回位图图片</span><br><span class="line">        return imageWithoutAlpha;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//解压并按比例缩小图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)sd_decompressedAndScaledDownImageWithImage:(nullable UIImage *)image &#123;</span><br><span class="line">    //如果图片不需要解码，直接返回image</span><br><span class="line">    if (![[self class] shouldDecodeImage:image]) &#123;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //如果图片不需要缩小，直接执行解压图片操作</span><br><span class="line">    if (![[self class] shouldScaleDownImage:image]) &#123;</span><br><span class="line">        return [self sd_decompressedImageWithImage:image];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 创建图像上下文</span><br><span class="line">    CGContextRef destContext;</span><br><span class="line">    </span><br><span class="line">    //自动释放位图上下文和所有变量以帮助系统在存在内存警告时释放内存。</span><br><span class="line">    //在iOS7上，别忘了调用[[SDImageCache sharedImageCache] clearMemory];</span><br><span class="line">    </span><br><span class="line">    // 建立自动释放池，以帮助系统在收到内存警告时释放内存</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        //获取图片对象的位图图片</span><br><span class="line">        CGImageRef sourceImageRef = image.CGImage;</span><br><span class="line">        </span><br><span class="line">        // 获取图像的总像素数</span><br><span class="line">        CGSize sourceResolution = CGSizeZero;</span><br><span class="line">        sourceResolution.width = CGImageGetWidth(sourceImageRef);</span><br><span class="line">        sourceResolution.height = CGImageGetHeight(sourceImageRef);</span><br><span class="line">        float sourceTotalPixels = sourceResolution.width * sourceResolution.height;</span><br><span class="line">        </span><br><span class="line">        // 计算缩小比例</span><br><span class="line">        float imageScale = kDestTotalPixels / sourceTotalPixels;</span><br><span class="line">        // 计算缩小后的尺寸</span><br><span class="line">        CGSize destResolution = CGSizeZero;</span><br><span class="line">        destResolution.width = (int)(sourceResolution.width*imageScale);</span><br><span class="line">        destResolution.height = (int)(sourceResolution.height*imageScale);</span><br><span class="line">        </span><br><span class="line">        // 获取色彩空间</span><br><span class="line">        CGColorSpaceRef colorspaceRef = SDCGColorSpaceGetDeviceRGB();</span><br><span class="line">        BOOL hasAlpha = SDCGImageRefContainsAlpha(sourceImageRef);</span><br><span class="line">        // iOS 显示 Alpha（透明）信息 (BGRA8888/BGRX8888)</span><br><span class="line">        CGBitmapInfo bitmapInfo = kCGBitmapByteOrder32Host;</span><br><span class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</span><br><span class="line">        </span><br><span class="line">        // CGBitmapContextCreate不支持kCGImageAlphaNone。由于此处的原始图像没有alpha信息，因此使用kCGImageAlphaNoneSkipLast创建没有alpha信息的位图图形上下文。</span><br><span class="line">        //创建位图图形上下文</span><br><span class="line">        destContext = CGBitmapContextCreate(NULL,</span><br><span class="line">                                            destResolution.width,</span><br><span class="line">                                            destResolution.height,</span><br><span class="line">                                            kBitsPerComponent,</span><br><span class="line">                                            0,</span><br><span class="line">                                            colorspaceRef,</span><br><span class="line">                                            bitmapInfo);</span><br><span class="line">        </span><br><span class="line">        //如果创建失败，直接返回image</span><br><span class="line">        if (destContext == NULL) &#123;</span><br><span class="line">            return image;</span><br><span class="line">        &#125;</span><br><span class="line">        // 设置图像上下文的绘图质量</span><br><span class="line">        CGContextSetInterpolationQuality(destContext, kCGInterpolationHigh);</span><br><span class="line">        </span><br><span class="line">        //现在定义用于从输入图像到输出图像的增量blit的矩形的大小。由于iOS从磁盘检索图像数据的方式，我们使用的源块宽度等于源图像的宽度。 iOS必须以全宽“波段”从磁盘解码图像，即使当前图形上下文被剪切为该波段内的子图形也是如此。 因此，我们通过将我们的图块大小设置为输入图像的整个宽度来充分利用由解码操作产生的所有像素数据。</span><br><span class="line">        </span><br><span class="line">        // 创建临时变量保存来源块大小</span><br><span class="line">        CGRect sourceTile = CGRectZero;</span><br><span class="line">        // 来源块的宽度就是原图的宽度</span><br><span class="line">        sourceTile.size.width = sourceResolution.width;</span><br><span class="line">        </span><br><span class="line">        // 源图块高度是动态的。 由于我们以MB为单位指定了源块的大小，因此请查看输入图像宽度可以为多少像素行。</span><br><span class="line">        // 计算来源块的高度</span><br><span class="line">        sourceTile.size.height = (int)(kTileTotalPixels / sourceTile.size.width );</span><br><span class="line">        // 设置来源块的X坐标</span><br><span class="line">        sourceTile.origin.x = 0.0f;</span><br><span class="line">        </span><br><span class="line">        //输出图块与输入图块的比例相同，但缩放为图像比例。</span><br><span class="line">        // 创建历史变量保存目标块大小</span><br><span class="line">        CGRect destTile;</span><br><span class="line">        </span><br><span class="line">        // 目标块的宽是缩放后的宽</span><br><span class="line">        destTile.size.width = destResolution.width;</span><br><span class="line">        </span><br><span class="line">        // 目标块的宽是来源块的高乘以缩放比</span><br><span class="line">        destTile.size.height = sourceTile.size.height * imageScale;</span><br><span class="line">        </span><br><span class="line">        // 设置目标块的X坐标</span><br><span class="line">        destTile.origin.x = 0.0f;</span><br><span class="line">        </span><br><span class="line">        //来源块与目标似乎重叠成比例。 这是我们组装输出图像时每个图块重叠的像素数量。</span><br><span class="line">        // 计算来源块与目标块的重复区域</span><br><span class="line">        float sourceSeemOverlap = (int)((kDestSeemOverlap/destResolution.height)*sourceResolution.height);</span><br><span class="line">        </span><br><span class="line">        // 生成变量保存来源块图像位图</span><br><span class="line">        CGImageRef sourceTileImageRef;</span><br><span class="line">        </span><br><span class="line">        // 计算组装输出图像所需的读/写操作次数。</span><br><span class="line">        // 计算需要绘制的次数</span><br><span class="line">        int iterations = (int)( sourceResolution.height / sourceTile.size.height );</span><br><span class="line">        </span><br><span class="line">        // 如果图块高度未均匀划分图像高度，请添加另一个迭代以考虑剩余像素。</span><br><span class="line">        // 计算剩余像素的高度</span><br><span class="line">        int remainder = (int)sourceResolution.height % (int)sourceTile.size.height;</span><br><span class="line">        </span><br><span class="line">        // 如果有剩余像素就将绘制次数加1</span><br><span class="line">        if(remainder) &#123;</span><br><span class="line">            iterations++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 添加似乎与切片重叠，但保存原始切片高度以进行y坐标计算。</span><br><span class="line">         // 创建变量保存来源块的高度，用来计算纵坐标的移动</span><br><span class="line">        float sourceTileHeightMinusOverlap = sourceTile.size.height;</span><br><span class="line">        </span><br><span class="line">        // 来源块高度加上要重复覆盖的高度</span><br><span class="line">        sourceTile.size.height += sourceSeemOverlap;</span><br><span class="line">        </span><br><span class="line">        // 目标块高度加上重叠的像素数</span><br><span class="line">        destTile.size.height += kDestSeemOverlap;</span><br><span class="line">        </span><br><span class="line">        // 开启循环绘制图像</span><br><span class="line">        for( int y = 0; y &lt; iterations; ++y ) &#123;</span><br><span class="line">            // 建立自动释放池，以帮助系统在收到内存警告时释放内存。</span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">                // 计算来源块的纵坐标：来源块的高度乘以当前循环次数，然后加上重复覆盖的高度</span><br><span class="line">                sourceTile.origin.y = y * sourceTileHeightMinusOverlap + sourceSeemOverlap;</span><br><span class="line">                </span><br><span class="line">                 // 计算目标块的纵坐标：目标图像的高度减去要绘制的来源块的高度乘以压缩比，再减去重叠高度</span><br><span class="line">                // 这个地方，来源块的纵坐标是递增的，目标块的纵坐标是递减的，这是因为为UIKit的坐标系和CGContext是镜像关系</span><br><span class="line">                destTile.origin.y = destResolution.height - (( y + 1 ) * sourceTileHeightMinusOverlap * imageScale + kDestSeemOverlap);</span><br><span class="line">                </span><br><span class="line">                // 按照计算好的尺寸绘制来源块的位图</span><br><span class="line">                sourceTileImageRef = CGImageCreateWithImageInRect( sourceImageRef, sourceTile );</span><br><span class="line">                </span><br><span class="line">                 // 如果是最后一块要绘制，并且这一块是剩余的像素</span><br><span class="line">                if( y == iterations - 1 &amp;&amp; remainder ) &#123;</span><br><span class="line">                </span><br><span class="line">                    // 因为剩余像素的高度是不固定的，所以重新计算目标块的纵坐标</span><br><span class="line">                    float dify = destTile.size.height;</span><br><span class="line">                    destTile.size.height = CGImageGetHeight( sourceTileImageRef ) * imageScale;</span><br><span class="line">                    dify -= destTile.size.height;</span><br><span class="line">                    destTile.origin.y += dify;</span><br><span class="line">                &#125;</span><br><span class="line">                // 将来源块位图按照计算好的尺寸绘制到目标图像上下文中</span><br><span class="line">                CGContextDrawImage( destContext, destTile, sourceTileImageRef );</span><br><span class="line">                </span><br><span class="line">                 // 释放来源块位图</span><br><span class="line">                CGImageRelease( sourceTileImageRef );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 根据目标图像上下文生成目标图像位图</span><br><span class="line">        CGImageRef destImageRef = CGBitmapContextCreateImage(destContext);</span><br><span class="line">        </span><br><span class="line">        // 释放目标图像上下文</span><br><span class="line">        CGContextRelease(destContext);</span><br><span class="line">        </span><br><span class="line">        // 如果生成位图失败就直接返回图片对象</span><br><span class="line">        if (destImageRef == NULL) &#123;</span><br><span class="line">            return image;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         // 生成目标图片对象</span><br><span class="line">        UIImage *destImage = [[UIImage alloc] initWithCGImage:destImageRef scale:image.scale orientation:image.imageOrientation];</span><br><span class="line">        </span><br><span class="line">         // 释放目标图像位图</span><br><span class="line">        CGImageRelease(destImageRef);</span><br><span class="line">        </span><br><span class="line">        // 如果生成图片对象失败就直接返回图片对象</span><br><span class="line">        if (destImage == nil) &#123;</span><br><span class="line">            return image;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 返回目标图片对象</span><br><span class="line">        return destImage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>判断某个图片格式是否支持编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//如果是WebP格式，则不支持编码；HEIC格式：根据canEncodeToHEICFormat方法判断是否支持编码；其他格式都支持编码</span><br><span class="line">- (BOOL)canEncodeToFormat:(SDImageFormat)format &#123;</span><br><span class="line">    switch (format) &#123;</span><br><span class="line">        case SDImageFormatWebP:</span><br><span class="line">            // 不支持WebP格式编码</span><br><span class="line">            return NO;</span><br><span class="line">        case SDImageFormatHEIC:</span><br><span class="line">            // 检查HEIC编码兼容性</span><br><span class="line">            return [[self class] canEncodeToHEICFormat];</span><br><span class="line">        default:</span><br><span class="line">            return YES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将图片根据给定的格式解码成图片数据（imageData）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">- (NSData *)encodedDataWithImage:(UIImage *)image format:(SDImageFormat)format &#123;</span><br><span class="line">    //如果图片不存在，返回nil</span><br><span class="line">    if (!image) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //如果格式类型未识别，判断图片是否含有Alpha通道，如果有则定义为PNG格式，否则定义为JPEG格式</span><br><span class="line">    if (format == SDImageFormatUndefined) &#123;</span><br><span class="line">        BOOL hasAlpha = SDCGImageRefContainsAlpha(image.CGImage);</span><br><span class="line">        if (hasAlpha) &#123;</span><br><span class="line">            format = SDImageFormatPNG;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            format = SDImageFormatJPEG;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSMutableData *imageData = [NSMutableData data];</span><br><span class="line">    CFStringRef imageUTType = [NSData sd_UTTypeFromSDImageFormat:format];</span><br><span class="line">    </span><br><span class="line">    // 根据imageData 和 CFStringRef 创建 CGImageDestinationRef对象，如果创建失败，返回nil</span><br><span class="line">    CGImageDestinationRef imageDestination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData, imageUTType, 1, NULL);</span><br><span class="line">    if (!imageDestination) &#123;</span><br><span class="line">        // Handle failure.</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //创建字典对象保存编码参数</span><br><span class="line">    NSMutableDictionary *properties = [NSMutableDictionary dictionary];</span><br><span class="line">#if SD_UIKIT || SD_WATCH</span><br><span class="line">    //// 获取图片的方向</span><br><span class="line">    NSInteger exifOrientation = [SDWebImageCoderHelper exifOrientationFromImageOrientation:image.imageOrientation];</span><br><span class="line">    //设置方向参数</span><br><span class="line">    [properties setValue:@(exifOrientation) forKey:(__bridge NSString *)kCGImagePropertyOrientation];</span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">    // 添加图片位图对象到创建的CGImageDestinationRef对象中</span><br><span class="line">    CGImageDestinationAddImage(imageDestination, image.CGImage, (__bridge CFDictionaryRef)properties);</span><br><span class="line">    </span><br><span class="line">    // 如果编码失败就返回空</span><br><span class="line">    if (CGImageDestinationFinalize(imageDestination) == NO) &#123;</span><br><span class="line">        // Handle failure.</span><br><span class="line">        imageData = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //释放掉imageDestination对象</span><br><span class="line">    CFRelease(imageDestination);</span><br><span class="line">    </span><br><span class="line">    //返回</span><br><span class="line">    return [imageData copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="私有方法（辅助方法）"><a href="#私有方法（辅助方法）" class="headerlink" title="私有方法（辅助方法）"></a>私有方法（辅助方法）</h3><ol><li>是否需要解压图片<br>（如果图片为动图或不存在，不解压图片，否则解压图片）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)shouldDecodeImage:(nullable UIImage *)image &#123;</span><br><span class="line">    //如果图片为空，返回NO</span><br><span class="line">    if (image == nil) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 如果图片为动图，返回NO</span><br><span class="line">    if (image.images != nil) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    否则返回YES</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>是否支持<code>HEIC</code>格式类型的图片解码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)canDecodeFromHEICFormat &#123;</span><br><span class="line">    //临时静态变量 canDecode 为 NO</span><br><span class="line">    static BOOL canDecode = NO;</span><br><span class="line">    </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    </span><br><span class="line">//忽略-Wunguarded-availability警告   </span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wunguarded-availability&quot;</span><br><span class="line"></span><br><span class="line">//如果是iWatch 或者 SIMULATOR ，则不支持</span><br><span class="line">#if TARGET_OS_SIMULATOR || SD_WATCH  //iWatch</span><br><span class="line">        canDecode = NO;</span><br><span class="line">        </span><br><span class="line">#elif SD_MAC  //mac</span><br><span class="line">        </span><br><span class="line">        //获取进程信息对象</span><br><span class="line">        NSProcessInfo *processInfo = [NSProcessInfo processInfo];</span><br><span class="line">        if ([processInfo respondsToSelector:@selector(operatingSystemVersion)]) &#123;</span><br><span class="line">            //通过进程信息对象获取操作系统版本。判断macOS系统版本10.13+，则支持HEIC类型图像的解码</span><br><span class="line">            canDecode = processInfo.operatingSystemVersion.minorVersion &gt;= 13;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            canDecode = NO;</span><br><span class="line">        &#125;</span><br><span class="line">#elif SD_UIKIT //iOS 和 tvOS</span><br><span class="line">        //获取进程信息对象</span><br><span class="line">        NSProcessInfo *processInfo = [NSProcessInfo processInfo];</span><br><span class="line">        if ([processInfo respondsToSelector:@selector(operatingSystemVersion)]) &#123;</span><br><span class="line">            //通过进程信息对象获取操作系统版本。判断操作系统版本是iOS 11+就支持HEIC类型图像的解码</span><br><span class="line">            canDecode = processInfo.operatingSystemVersion.majorVersion &gt;= 11;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            canDecode = NO;</span><br><span class="line">        &#125;</span><br><span class="line">#endif</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">    &#125;);</span><br><span class="line">    return canDecode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>是否支持<code>HEIC</code>格式类型的图片编码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)canEncodeToHEICFormat &#123;</span><br><span class="line">    //临时静态变量 canDecode 为 NO</span><br><span class="line">    static BOOL canEncode = NO;</span><br><span class="line">    </span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        NSMutableData *imageData = [NSMutableData data];</span><br><span class="line">        CFStringRef imageUTType = [NSData sd_UTTypeFromSDImageFormat:SDImageFormatHEIC];</span><br><span class="line">        </span><br><span class="line">        // 创建一个CGImageDestinationRef对象，如果该对象可以创建成功，则需要编码，否则不需要</span><br><span class="line">        CGImageDestinationRef imageDestination = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)imageData, imageUTType, 1, NULL);</span><br><span class="line">        if (!imageDestination) &#123;</span><br><span class="line">            // Can&apos;t encode to HEIC</span><br><span class="line">            canEncode = NO;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Can encode to HEIC</span><br><span class="line">            CFRelease(imageDestination);</span><br><span class="line">            canEncode = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return canEncode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>是否应该缩小图片</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#if SD_UIKIT || SD_WATCH</span><br><span class="line">+ (BOOL)shouldScaleDownImage:(nonnull UIImage *)image &#123;</span><br><span class="line">    BOOL shouldScaleDown = YES;</span><br><span class="line">    </span><br><span class="line">    //获取图片的位图图像</span><br><span class="line">    CGImageRef sourceImageRef = image.CGImage;</span><br><span class="line">    </span><br><span class="line">    //获取到位图图像的宽和高</span><br><span class="line">    CGSize sourceResolution = CGSizeZero;</span><br><span class="line">    sourceResolution.width = CGImageGetWidth(sourceImageRef);</span><br><span class="line">    sourceResolution.height = CGImageGetHeight(sourceImageRef);</span><br><span class="line">    </span><br><span class="line">    //计算图片的总像素数</span><br><span class="line">    float sourceTotalPixels = sourceResolution.width * sourceResolution.height;</span><br><span class="line">    </span><br><span class="line">    //图片的压缩比： 最大像素数 / 图片的总像素数</span><br><span class="line">    float imageScale = kDestTotalPixels / sourceTotalPixels;</span><br><span class="line">    </span><br><span class="line">    //如果压缩比小于1，返回YES，否则返回NO</span><br><span class="line">    if (imageScale &lt; 1) &#123;</span><br><span class="line">        shouldScaleDown = YES;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        shouldScaleDown = NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return shouldScaleDown;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;SDWebImage&lt;/code&gt; 内部实现了一个图片解码/编码的图片编码器，用于图片的编解码、压缩。其中涉及到编解码管理（&lt;code&gt;SDWebImageCodersManager&lt;/code&gt;）、编解码协议（&lt;code&gt;SDWebImageCoder&lt;/code&gt;）、PNG/JPEG/TIFF编解码，解压缩，显示大图（&lt;code&gt;SDWebImageImageIOCoder&lt;/code&gt;）、GIF编解码（&lt;code&gt;SDWebImageGIFCoder&lt;/code&gt;）、WebP编解码（&lt;code&gt;SDWebImageWebPCoder&lt;/code&gt;）以及辅助类（&lt;code&gt;SDWebImageCoderHelper&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SDWebImageImageIOCoder&lt;/code&gt; ：内置编码器，支持PNG，JPEG，TIFF，支持逐行解码。该类遵守 &lt;code&gt;SDWebImageProgressiveCoder&lt;/code&gt;协议。该协议也遵守&lt;code&gt;SDWebImageCoder&lt;/code&gt;协议，所以这个类要实现这两个协议的方法。&lt;/p&gt;
&lt;p&gt;  GIF&lt;br&gt;  还支持静态GIF（意思是只处理第一帧）。&lt;br&gt;  要获得完整的GIF支持，我们建议使用&lt;code&gt;FLAnimatedImage&lt;/code&gt;或性能较差的&lt;code&gt;SDWebImageGIFCoder&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  HEIC&lt;br&gt;  该编码器还支持HEIC格式，因为ImageIO本身支持它。但这取决于系统功能，因此无法在所有设备上运行。
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
  <entry>
    <title>读 SDWebImage 六 （编码器三：SDWebImageCodersManager）</title>
    <link href="http://guohuaden.com/2018/10/18/Read-SDWebImage-SDWebImageCodersManager/"/>
    <id>http://guohuaden.com/2018/10/18/Read-SDWebImage-SDWebImageCodersManager/</id>
    <published>2018-10-18T12:48:55.000Z</published>
    <updated>2018-10-29T09:59:10.285Z</updated>
    
    <content type="html"><![CDATA[<p><code>SDWebImage</code> 内部实现了一个图片解码/编码的图片编解码器，用于图片的编解码、压缩。其中涉及到编解码管理（<code>SDWebImageCodersManager</code>）、编解码协议（<code>SDWebImageCoder</code>）、PNG/JPEG/TIFF编解码，解压缩，显示大图（<code>SDWebImageImageIOCoder</code>）、GIF编解码（<code>SDWebImageGIFCoder</code>）、WebP编解码（<code>SDWebImageWebPCoder</code>）以及辅助类（<code>SDWebImageCoderHelper</code>）</p><h3 id="编解码管理（-SDWebImageCodersManager-）"><a href="#编解码管理（-SDWebImageCodersManager-）" class="headerlink" title="编解码管理（ SDWebImageCodersManager ）"></a>编解码管理（ <code>SDWebImageCodersManager</code> ）</h3><p>编解码管理器，整体编解码器的入口，该类遵守了 <code>SDWebImageCoder</code> 协议，说明这个类可以提供基本的编解码功能 。编解码器数组是一个优先级队列，也意味着处理多个图片编解码任务时新添加的编解码器将具有最高优先级（即被先调用）<a id="more"></a></p><h4 id="声明属性和方法"><a href="#声明属性和方法" class="headerlink" title="声明属性和方法"></a>声明属性和方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 单例初始化</span><br><span class="line"> */</span><br><span class="line">+ (nonnull instancetype)sharedInstance;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 所有的编解码器都在这个编解码器管理中（编码器数组）这个编解码器数组是一个优先级对列, 这意味着最后添加的编解码器拥有最高的优先级</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, copy, readwrite, nullable) NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 在编解码器数组的末尾添加一个新的编解码器。 新添加的编解码器优先级最高。</span><br><span class="line"></span><br><span class="line"> @param coder 需添加的coder</span><br><span class="line"> */</span><br><span class="line">- (void)addCoder:(nonnull id&lt;SDWebImageCoder&gt;)coder;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 在编解码器数组中移除编码器</span><br><span class="line"></span><br><span class="line"> @param coder 需移除的coder</span><br><span class="line"> */</span><br><span class="line">- (void)removeCoder:(nonnull id&lt;SDWebImageCoder&gt;)coder;</span><br></pre></td></tr></table></figure><h4 id="初始化方法实现"><a href="#初始化方法实现" class="headerlink" title="初始化方法实现"></a>初始化方法实现</h4><p>初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//单例</span><br><span class="line">+ (nonnull instancetype)sharedInstance &#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    static id instance;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">        instance = [self new];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        // 初始化默认的编解码器，默认编码器只有SDWebImageImageIOCoder类型的</span><br><span class="line">        NSMutableArray&lt;id&lt;SDWebImageCoder&gt;&gt; *mutableCoders = [@[[SDWebImageImageIOCoder sharedCoder]] mutableCopy];</span><br><span class="line">#ifdef SD_WEBP</span><br><span class="line">        //如果是WEBP，就添加SDWebImageWebPCoder单例</span><br><span class="line">        [mutableCoders addObject:[SDWebImageWebPCoder sharedCoder]];</span><br><span class="line">#endif</span><br><span class="line">        _coders = [mutableCoders copy];</span><br><span class="line">        _codersLock = dispatch_semaphore_create(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编码器IO操作"><a href="#编码器IO操作" class="headerlink" title="编码器IO操作"></a>编码器IO操作</h4><p>添加编码器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)addCoder:(nonnull id&lt;SDWebImageCoder&gt;)coder &#123;</span><br><span class="line">    //判断要添加的编解码器是否遵守SDWebImageCoder协议，以提供最基本的编解码功能</span><br><span class="line">    //如果不遵守SDWebImageCoder协议，返回</span><br><span class="line">    if (![coder conformsToProtocol:@protocol(SDWebImageCoder)]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    LOCK(self.codersLock);</span><br><span class="line">    //临时变量，编解码器数组，如果不存在，重新初始化一个</span><br><span class="line">    NSMutableArray&lt;id&lt;SDWebImageCoder&gt;&gt; *mutableCoders = [self.coders mutableCopy];</span><br><span class="line">    if (!mutableCoders) &#123;</span><br><span class="line">        mutableCoders = [NSMutableArray array];</span><br><span class="line">    &#125;</span><br><span class="line">    //添加新的coder</span><br><span class="line">    [mutableCoders addObject:coder];</span><br><span class="line">    //重新赋值给self.coders</span><br><span class="line">    self.coders = [mutableCoders copy];</span><br><span class="line">    UNLOCK(self.codersLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移除编码器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeCoder:(nonnull id&lt;SDWebImageCoder&gt;)coder &#123;</span><br><span class="line">    //判断要添加的编解码器是否遵守SDWebImageCoder协议，以提供最基本的编解码功能</span><br><span class="line">    //如果不遵守SDWebImageCoder协议，返回</span><br><span class="line">    if (![coder conformsToProtocol:@protocol(SDWebImageCoder)]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    LOCK(self.codersLock);</span><br><span class="line">    //临时变量，编解码器数组，使其等于self.coders（深拷贝）</span><br><span class="line">    NSMutableArray&lt;id&lt;SDWebImageCoder&gt;&gt; *mutableCoders = [self.coders mutableCopy];</span><br><span class="line">    //移除编解码器coder</span><br><span class="line">    [mutableCoders removeObject:coder];</span><br><span class="line">     //重新赋值给self.coders</span><br><span class="line">    self.coders = [mutableCoders copy];</span><br><span class="line">    UNLOCK(self.codersLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SDWebImageCoder协议方法实现"><a href="#SDWebImageCoder协议方法实现" class="headerlink" title="SDWebImageCoder协议方法实现"></a>SDWebImageCoder协议方法实现</h4><p>解码协议实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 如果此编解码器可以解码某些data，返回YES，否则，它应该传递给另一个编码器</span><br><span class="line"> </span><br><span class="line"> @param data 需要解码的图片数据</span><br><span class="line"> @return 如果此编解码器可以解码图片数据，返回YES，否则返回NO</span><br><span class="line"> */</span><br><span class="line">- (BOOL)canDecodeFromData:(NSData *)data &#123;</span><br><span class="line">    LOCK(self.codersLock);</span><br><span class="line">    //临时变量，编解码器数组，赋值等于 self.coders</span><br><span class="line">    NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders = self.coders;</span><br><span class="line">    UNLOCK(self.codersLock);</span><br><span class="line">    //倒序遍历编解码器数组（倒序的原因是：编解码器数组中最新添加的具有最高优先级）</span><br><span class="line">    for (id&lt;SDWebImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123;</span><br><span class="line">        //判断，如果其中有编解码器能够解码，就返回YES，否则返回NO</span><br><span class="line">        if ([coder canDecodeFromData:data]) &#123;</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 将图片数据解码为图片。</span><br><span class="line"> </span><br><span class="line"> @param data 需要解码的图片数据</span><br><span class="line"> @return 解码后得到的图片</span><br><span class="line"> */</span><br><span class="line">- (UIImage *)decodedImageWithData:(NSData *)data &#123;</span><br><span class="line">    LOCK(self.codersLock);</span><br><span class="line">    NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders = self.coders;</span><br><span class="line">    UNLOCK(self.codersLock);</span><br><span class="line">    //倒序遍历编解码器列表</span><br><span class="line">    for (id&lt;SDWebImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123;</span><br><span class="line">        //判断，如果其中有编解码器能够解码，就执行解码操作，否则返回Image为nil</span><br><span class="line">        if ([coder canDecodeFromData:data]) &#123;</span><br><span class="line">            return [coder decodedImageWithData:data];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">使用原始图片和图片数据解压缩图片。</span><br><span class="line"></span><br><span class="line"> @param image 需要压缩的原图片</span><br><span class="line"> @param data 指向原始图像数据的指针。 指针本身是非空的，但图像数据可以为空。 如果需要，此数据将设置为缓存。 如果您不需要同时修改数据，请忽略此参数。</span><br><span class="line"> @param optionsDict 一个包含任何解压缩选项的字典。 通过&#123;SDWebImageCoderScaleDownLargeImagesKey：@（YES）&#125;缩小大图像</span><br><span class="line"> @return 解压缩后的图片</span><br><span class="line"> */</span><br><span class="line">- (UIImage *)decompressedImageWithImage:(UIImage *)image</span><br><span class="line">                                   data:(NSData *__autoreleasing  _Nullable *)data</span><br><span class="line">                                options:(nullable NSDictionary&lt;NSString*, NSObject*&gt;*)optionsDict &#123;</span><br><span class="line">    //如果image不存在，返回nil</span><br><span class="line">    if (!image) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    LOCK(self.codersLock);</span><br><span class="line">    NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders = self.coders;</span><br><span class="line">    UNLOCK(self.codersLock);</span><br><span class="line">    //倒序遍历编解码器列表</span><br><span class="line">    for (id&lt;SDWebImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123;</span><br><span class="line">        //如果其中有编解码器可以解码，执行解压缩图片操作，并返回解压缩后的图片</span><br><span class="line">        if ([coder canDecodeFromData:*data]) &#123;</span><br><span class="line">            //解压缩图片操作</span><br><span class="line">            UIImage *decompressedImage = [coder decompressedImageWithImage:image data:data options:optionsDict];</span><br><span class="line">            decompressedImage.sd_imageFormat = image.sd_imageFormat;</span><br><span class="line">            return decompressedImage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编码协议实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> 如果此编码器可以编码某些图片格式，返回YES，否则，它应该传递给另一个编码器</span><br><span class="line"> </span><br><span class="line"> @param format 图片格式</span><br><span class="line"> @return 如果此编码器可以编码图片格式，返回YES，否则返回NO</span><br><span class="line"> */</span><br><span class="line">- (BOOL)canEncodeToFormat:(SDImageFormat)format &#123;</span><br><span class="line">    LOCK(self.codersLock);</span><br><span class="line">    NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders = self.coders;</span><br><span class="line">    UNLOCK(self.codersLock);</span><br><span class="line">    //倒序遍历编解码器列表</span><br><span class="line">    for (id&lt;SDWebImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123;</span><br><span class="line">        //判断，如果其中有编解码器能够编码图片格式，就返回YES，否则返回NO</span><br><span class="line">        if ([coder canEncodeToFormat:format]) &#123;</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 将图片编码为图片数据（imagedata）</span><br><span class="line"></span><br><span class="line"> @param image 需要编码的图片</span><br><span class="line"> @param format 要编码的图片格式, 也有可能是 `SDImageFormatUndefined` 格式（未识别格式）</span><br><span class="line"> @return The encoded image data</span><br><span class="line"> */</span><br><span class="line">- (NSData *)encodedDataWithImage:(UIImage *)image format:(SDImageFormat)format &#123;</span><br><span class="line">    //如果image不存在，返回nil</span><br><span class="line">    if (!image) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    LOCK(self.codersLock);</span><br><span class="line">    NSArray&lt;id&lt;SDWebImageCoder&gt;&gt; *coders = self.coders;</span><br><span class="line">    UNLOCK(self.codersLock);</span><br><span class="line">    //倒序遍历编解码器列表</span><br><span class="line">    for (id&lt;SDWebImageCoder&gt; coder in coders.reverseObjectEnumerator) &#123;</span><br><span class="line">        //判断，如果其中有编解码器能够编码图片格式，就执行将图片以format格式编码为data操作，并返回imagedata</span><br><span class="line">        if ([coder canEncodeToFormat:format]) &#123;</span><br><span class="line">            // 将图片编码为图片数据（imagedata）</span><br><span class="line">            return [coder encodedDataWithImage:image format:format];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;SDWebImage&lt;/code&gt; 内部实现了一个图片解码/编码的图片编解码器，用于图片的编解码、压缩。其中涉及到编解码管理（&lt;code&gt;SDWebImageCodersManager&lt;/code&gt;）、编解码协议（&lt;code&gt;SDWebImageCoder&lt;/code&gt;）、PNG/JPEG/TIFF编解码，解压缩，显示大图（&lt;code&gt;SDWebImageImageIOCoder&lt;/code&gt;）、GIF编解码（&lt;code&gt;SDWebImageGIFCoder&lt;/code&gt;）、WebP编解码（&lt;code&gt;SDWebImageWebPCoder&lt;/code&gt;）以及辅助类（&lt;code&gt;SDWebImageCoderHelper&lt;/code&gt;）&lt;/p&gt;
&lt;h3 id=&quot;编解码管理（-SDWebImageCodersManager-）&quot;&gt;&lt;a href=&quot;#编解码管理（-SDWebImageCodersManager-）&quot; class=&quot;headerlink&quot; title=&quot;编解码管理（ SDWebImageCodersManager ）&quot;&gt;&lt;/a&gt;编解码管理（ &lt;code&gt;SDWebImageCodersManager&lt;/code&gt; ）&lt;/h3&gt;&lt;p&gt;编解码管理器，整体编解码器的入口，该类遵守了 &lt;code&gt;SDWebImageCoder&lt;/code&gt; 协议，说明这个类可以提供基本的编解码功能 。编解码器数组是一个优先级队列，也意味着处理多个图片编解码任务时新添加的编解码器将具有最高优先级（即被先调用）
    
    </summary>
    
      <category term="读SDWebImage手札" scheme="http://guohuaden.com/categories/%E8%AF%BBSDWebImage%E6%89%8B%E6%9C%AD/"/>
    
    
      <category term="SDWebImage" scheme="http://guohuaden.com/tags/SDWebImage/"/>
    
  </entry>
  
</feed>
